{
    "collab_server" : "",
    "contents" : "#server options : 3 Mo maximum.\noptions(shiny.maxRequestSize = 3*1024^2)\n\nserver <-function(input,output,session){\n\n#REACTIVES\n\n  #Liste d'arbre = trees()\n  trees <- reactive({\n    withProgress(message = 'Trees are loading', value = 0, {\n      incProgress(1)\n      trees = read.tree(input$trees$datapath, keep.multi = TRUE)\n      if(is.null(names(trees))){\n        names(trees) = as.character(c(1:length(trees)))\n      }\n      trees=trees2trees(trees,bvalue=bvalue())\n    })\n    return(trees)\n  })\n\n  #Patristique ou nodal = choice()\n  choice <- reactive({\n    input$choice\n  })\n  impMethode <- reactive({\n    input$impMet\n  })\n\n  #k = k()\n  k <- reactive({\n    input$k\n  })\n  #bvalue = bvalue\n  bvalue <- reactive({\n    if(!is.null(input$bvalue)){\n      bvalue = input$bvalue\n    }\n    else{\n      bvalue = 0\n    }\n    return(bvalue)\n  })\n\n  #Liste de matrices de distances = mat()\n  mat <- reactive({\n    withProgress(message = 'imputation', value = 0, {\n      incProgress(1)\n      trees = trees()\n      if(is.null(names(trees))){\n        names(trees)=as.character(c(1:length(trees)))\n      }\n      mat <- trees2matrices(trees, distance = choice(), bvalue = bvalue())\n      if (impMethode() == \"MEAN\") {\n        mat = impMean(mat)\n      }\n      else if (impMethode() == \"IPCA\") {\n        impPCA.multi(mat, maxiter=1000)\n      }\n      return(mat)\n    })\n  })\n\n  #Distatis = Dist()\n  dist <- reactive({\n    mat2Dist(mat())\n  })\n  #matrice FS (position moyenne des espèces)\n  FS <- reactive({\n    dist()$res4Splus$F\n  })\n  #matrice PF: positions relative des espèces\n  PF <- reactive({\n    PF = dist()$res4Splus$PartialF\n    if(is.null(dimnames(PF)[[3]])){\n      if(!is.null(names(trees()))){\n        dimnames(PF)[[3]] = names(trees())\n      }\n      else {\n        dimnames(PF)[[3]] = as.character(c(1:length(trees())))\n      }\n    }\n    return(PF)\n  })\n  #matrice G : ACP de la matrices des RV\n  G <- reactive({\n    G=dist()$res4Cmat$G\n    if(is.null(rownames(G))){\n     if(!is.null(names(trees()))){\n       rownames(G)<-names(trees())\n      }\n      else{\n        rownames(G)<-as.character(c(1:length(trees())))\n      }\n    }\n    return(G)\n  })\n  #matrice C / matrices des RV\n  C <- reactive({\n    C=dist()$res4Cmat$C\n    rownames(C) = paste(\"G\",names(trees()),sep=\"\")\n    colnames(C) = paste(\"G\",names(trees()),sep=\"\")\n    return(C)\n  })\n\n  #matrice WR = WR()\n  WR <- reactive({\n    Dist2WR(dist())\n  })\n  #nombre d'espèces\n  outVar <- reactive({\n    sps<-rownames(mat()[[1]])\n    if (!is.null(sps)){\n      vars <- all.vars(parse(text = sps))\n    }\n  })\n  #Detection des outliers ou non = outliers()\n  outliers <- reactive({\n    input$Outlier\n  })\n  #Sortie de PhylteR = RES()\n  RES <- reactive({\n    withProgress(message = 'PhylteR is running', value = 0, {\n    trees = trees()\n      if(is.null(names(trees))){\n        names(trees)=as.character(c(1:length(trees)))\n      }\n      incProgress(1)\n      PhylteR(trees, distance = choice(), k=k(), method.imp = impMethode(), thres = 0.5, maxiter=1000, bvalue = bvalue())\n    })\n  })\n  #outgn()\n  outgn <- reactive({\n    paste(RES()$Complete$outgn)\n  })\n  #outsp()\n  outsp <- reactive({\n    paste(RES()$Complete$outsp)\n  })\n  #outcell()\n  outcell <- reactive({\n    if(!is.null(RES()$CellByCell$outcell)){\n      if(!is.null(nrow(RES()$CellByCell$outcell))){\n        outcell = data.frame(paste(RES()$CellByCell$outcell[,1]),paste(RES()$CellByCell$outcell[,2]))\n      }\n      #gestion de l'exeption qui fait que quand on a qu'un seul outlierCell la ligne unique n'est pas détecté comme une dataframe\n      else {\n        outcell = data.frame(paste(RES()$CellByCell$outcell[[1]]),paste(RES()$CellByCell$outcell[[2]]))\n      }\n    }\n    else {\n      outcell = NULL\n    }\n    return(outcell)\n  })\n  #Liste des arbres que l'utilisateur veux afficher = TreesList()\n  TreesList <- reactive({\n    input$Treeslist\n  })\n  #taille des plots\n  PlotHeight = reactive({\n    50*(length(outVar()))\n  })\n  ranges <- reactiveValues(x = NULL, y = NULL)\n\n  #Partition pour la visualisation des gènes\n  Partition <- reactive({\n    Partition = list()\n    c=1\n    l1 = 30\n    if(length(trees())<30){\n      Partition[[1]] = paste(\"1-\",length(trees()),sep=\"\")\n    }\n    else{\n      while (l1 < length(trees())){\n        p=names(trees())[l1]\n        k=paste(c, \"-\", p, sep=\"\")\n        Partition = append(Partition, k)\n        l1 =l1+30\n        c=c+30\n      }\n      if (l1 >= length(trees())){\n        k=paste(c, \"-\", length(trees()), sep=\"\")\n        Partition = append(Partition, k)\n      }\n    }\n    return(Partition)\n  ## GeneList()\n  })\n  Geneslist <- reactive({\n    input$Geneslist\n  })\n\n  #END OF REACTIVES\n\n  #download file test\n  output$downloadData <- downloadHandler(\n    filename = \"Aguileta-et-al-2008_TREES.txt\",\n    content = function(file) {\n      file.copy(\"www/Aguileta-et-al-2008_TREES.txt\", file)\n    },\n    contentType = \"txt\"\n  )\n\n  #What happens when we add datas\n  observeEvent(input$trees, {\n    observe({\n      updateSelectInput(session, inputId = \"Geneslist\", label = \"Select Genes\", choices = Partition(), selected = Partition()[[1]])\n    })\n\n    #reset all when a new trees appears\n      reset(\"GeneslistUI\")\n      reset(\"bvalue\")\n      reset(\"Geneslist\")\n      reset(\"Treeslist\")\n      reset(\"Outlier\")\n      reset(\"choice\")\n      reset(\"k\")\n      reset(\"outputPhylter1\")\n      reset(\"outputPhylter2\")\n      reset(\"outputPhylter3\")\n      reset(\"DataSetInfo\")\n      reset(\"DataSetProblem\")\n      updateNavbarPage(session, inputId=\"PhylteR\",selected = \"Welcome\")\n\n    #information sur le jeu de données : nombre de gènes + nombre d'espèces\n    output$DataSetInfo <- renderText ({\n      paste(\"This data set has \", length(trees()), \" genes and \", length(outVar()), \" species\", sep=\"\")\n    })\n\n    #activation of tabs\n    session$sendCustomMessage('activeNavs', 'visualize some trees')\n    session$sendCustomMessage('activeNavs', 'visualize species on distatis compromise')\n    session$sendCustomMessage('activeNavs', 'visualize genes')\n    session$sendCustomMessage('activeNavs', 'visualize distances')\n    session$sendCustomMessage('activeNavs', 'visualize 2WR')\n    session$sendCustomMessage('activeNavs', 'visualize correlation between genes')\n    observe({\n      if (!is.null(trees()[[1]]$node.label)){\n        if(!is.na(as.numeric(trees()[[1]]$node.label[[1]]))){\n          enable(id = \"bvalue\")\n          AllBvalue = vector()\n          for (i in 1:length(trees())){\n            AllBvalue = append(AllBvalue, trees()[[i]]$node.label)\n          }\n          updateSliderInput(session, inputId = \"bvalue\",  min = 0 , max = max(AllBvalue), step=ceiling(as.numeric(max(AllBvalue))/100))\n          output$BvalueInfo <- renderText({\n            paste(\"This data set contains bootstrap values between 0 and \", max(AllBvalue), sep = \"\")\n          })\n        }\n        else {\n          disable(id = \"bvalue\")\n          output$BvalueInfo <- renderText({\n            \"This data set doesn't contain bootstrap values\"\n          })\n        }\n      }\n      else {\n        disable(id = \"bvalue\")\n        output$BvalueInfo <- renderText({\n          \"This data set doesn't contain bootstrap values\"\n        })\n      }\n    })\n\n#Several tabs and plots are differents if the detection is on or off\n    observeEvent(outliers(), {\n\n      ##event = DETECTION OUTLIER ON\n      if (outliers()== \"on\"){\n\n       ##DataSetProblem --> est ce que le jeu de données est trop propre ou trop dégueu pour PhylteR?\n        if(length(G()[,1][G()[,1] < 0.9])==0){\n          output$DataSetProblem <- renderText({\n            paste(\n               \"</br>\",\n                \"The trees in this data set are so similar that a single branch length variation could be detected as an outlier. Be careful!\"\n            )\n          })\n        }\n        else if(length(G()[,1][G()[,1] > 0.7])==0){\n          output$DataSetProblem <- renderText({\n            paste(\n              \"</br>\",\n              \"The trees in this data set are too different or seems to contain too much outliers for PhylteR. Be careful!\"\n            )\n          })\n        }\n\n        ##Visualize some trees tab. We can type several trees in the box \"Sumit trees\", all separated by a \"-\" and trees are ploted.\n        observeEvent(input$SumitTrees,{\n          List = TreesList()\n          S = strsplit(List, \",\")\n          S = S[[1]]\n          output$plot1 <- renderPlot(height = 500*length(S), {\n            withProgress(message = 'Making plot', value = 0, {\n              if (length(S)==1){par(mfrow = c(1,1))}\n              if (length(S)>=2 && length(S)<=8){par(mfrow = c(ceiling(length(S)/2),2))}\n              if (length(S)>8 && length(S)<=30){par(mfrow = c(ceiling(length(S)/5),5))}\n              if (length(S)>30){par(mfrow = c(ceiling(length(S)/8),8))}\n              par(mar = c(0,0,1,0))\n              for (i in 1:length(S)){\n                incProgress(1/length(S))\n                gene.colors <- \"black\"\n                species.colors <- length(outVar())\n                if (length(outgn())!=0){\n                  for (j in 1:length(outgn())){\n                    if (outgn()[j]== S[i]){\n                      gene.colors = \"red\"\n                    }\n                  }\n                }\n                if (length(outsp())!=0){\n                  for (j in 1:length(outsp())){\n                      species.colors[which(species.colors==outsp()[j])] = \"darkgreen\"\n                  }\n                }\n                if (nrow(outcell())!=0 && !is.null(outcell())){\n                  for (j in 1:length(outcell()[,2])){\n                    if(outcell()[j,2]==S[i]){\n                      species.colors[which(species.colors==outcell()[j,1])] = \"blue\"\n                    }\n                  }\n                }\n                for (k in 1:length(species.colors)){\n                  if(species.colors[k] != \"darkgreen\" && species.colors[k] != \"blue\"){\n                    species.colors[k] <- \"black\"\n                  }\n                }\n                ape::plot.phylo(trees()[[S[i]]],  edge.color = gene.colors, tip.color = species.colors, main = S[i])\n              }\n            })\n          })\n        })\n        ##Observe species:\n        ##Update species in the menu \"selectspecies\" with the list of species in the tree.\n        observe({\n          updateSelectInput(session, \"selectSpecies\", selected= \"all\", choices = append(append(outVar(),\"mean\",after=0),\"all\", after=0))\n        })\n        observeEvent(input$selectSpecies, {\n          S=input$selectSpecies\n          #all species in different plot. All in the same scale.\n          if (S == \"all\"){\n            output$plot2 <- renderPlot(height = PlotHeight(), {\n              withProgress(message = 'Making plot', value = 0, {\n                par(mfrow=c(ceiling(length(outVar())/4),4))\n                par(mar=c(2,2,2,2))\n                part.design <- diag(dim(PF())[3])\n\n                for (sp in 1:length(outVar())){\n\n                  participant.colors <- rownames(G())\n                  fill.colors <- rownames(G())\n                  if (length(outgn())!=0){\n                    for (j in 1:length(outgn())){\n                      participant.colors[which(participant.colors==outgn()[j])] = \"red1\"\n                      fill.colors[which(fill.colors==outgn()[j])] = \"pink\"\n                    }\n                  }\n                  if (length(outcell()[,1])!=0){\n                    for (j in 1:length(outcell()[,2])){\n                      if(outcell()[j,1]==outVar()[sp]){\n                        participant.colors[which(participant.colors==outcell()[j,2])] = \"blue\"\n                        fill.colors[which(fill.colors==outcell()[j,2])] = \"paleturquoise\"\n                      }\n                    }\n                  }\n                  for (color in 1:length(participant.colors)){\n                    if(participant.colors[color] != \"red1\" && participant.colors[color] != \"blue\"){\n                      participant.colors[color] <- \"grey50\"\n                      fill.colors[color]=\"white\"\n                    }\n                  }\n\n                  incProgress(1/length(outVar()))\n                  to.plot <- t(PF()[sp, , ])\n                  center.point <- FS()[sp, c(1, 2)]\n                  center.rep <- matrix(center.point, dim(PF())[3], 2, byrow = TRUE)\n                  bound.mat <- rbind(center.rep, to.plot[, c(1, 2)])\n                  bound.mat <- bound.mat[as.vector(t(matrix(seq(1, nrow(bound.mat)), ncol = 2))), ]\n                  coltitle=\"black\"\n                  if(length(outsp())!=0){\n                    for (out in 1:length(outsp())){\n                      if (outsp()[out] == outVar()[sp]){\n                        coltitle = \"darkgreen\"\n                      }\n                    }\n                  }\n                  plot(to.plot, main = dimnames(PF())[[1]][sp], col.main=coltitle, cex.main= 1.5, col = participant.colors, cex=3.2, xlim = range(t(PF()[, 1, ])), ylim = range(t(PF()[, 2, ])), pch = 21, bg=fill.colors)\n                  points(bound.mat, type = \"l\", lty = 1, lwd = 1, col = \"grey70\")\n                  text(to.plot, labels = rownames(t(PF()[sp, , ])))\n                }\n              })\n            })\n          }\n          #mean position of each specie on a graph\n          if(S == \"mean\"){\n            output$plot2 <- renderPlot({\n              withProgress(message = 'Making plot', value = 0, {\n                incProgress(0)\n                item.design <- diag(dim(FS())[1])\n\n                participant.colors <- rownames(FS())\n                fill.colors <- rownames(FS())\n                if (length(outsp())!=0){\n                  for (j in 1:length(outsp())){\n                    participant.colors[which(participant.colors==outsp())[j]] = \"darkgreen\"\n                    fill.colors[which(fill.colors==outsp()[j])] = \"palegreen\"\n                  }\n                  participant.colors[which(participant.colors!=\"darkgreen\")] = \"grey50\"\n                  fill.colors[which(fill.colors!=\"palegreen\")] = \"white\"\n                }\n                else{\n                  participant.colors = \"grey50\"\n                  fill.colors=\"white\"\n                }\n\n                real.minimum <- min(FS())\n                real.maximum <- max(FS())\n                real.value <- max(c(abs(real.minimum), abs(real.maximum)))\n                plot(FS(), col = participant.colors, axes=F, cex = 3.5, ylim=c(-real.value,real.value),xlim=c(-real.value,real.value),pch = 21,bg=fill.colors)\n                axis(1, pos=0,lwd.ticks=0.5)\n                axis(2, pos=0,lwd.ticks=0.5)\n                text(FS(), rownames(FS()))\n              })\n            })\n          }\n          #single specie selected\n          if(S != \"mean\" && S != \"all\"){\n            output$plot2 <- renderPlot({\n              withProgress(message = 'Making plot', value = 0, {\n                incProgress(0)\n                part.design <- diag(dim(PF())[3])\n\n                participant.colors <- rownames(G())\n                fill.colors <- rownames(G())\n\n                if (length(outgn())!=0){\n                  for (j in 1:length(outgn())){\n                    participant.colors[which(participant.colors==outgn()[j])] = \"red1\"\n                    fill.colors[which(fill.colors==outgn()[j])] = \"pink\"\n                  }\n                }\n                  if (length(outcell()[,2])!=0){\n                    for (j in 1:length(outcell()[,2])){\n                        if(outcell()[j,1]==S){\n                          participant.colors[which(participant.colors==outcell()[j,2])] = \"blue\"\n                          fill.colors[which(fill.colors==outcell()[j,2])] = \"paleturquoise\"\n                      }\n                    }\n                  }\n                  for (color in 1:length(participant.colors)){\n                    if(participant.colors[color] != \"red1\" && participant.colors[color] != \"blue\"){\n                      participant.colors[color] <- \"grey50\"\n                      fill.colors[color]=\"white\"\n                    }\n                  }\n                to.plot <- t(PF()[S, , ])\n                center.point <- FS()[S, c(1, 2)]\n                center.rep <- matrix(center.point, dim(PF())[3], 2, byrow = TRUE)\n                bound.mat <- rbind(center.rep, to.plot[, c(1, 2)])\n                bound.mat <- bound.mat[as.vector(t(matrix(seq(1, nrow(bound.mat)), ncol = 2))), ]\n                plot(to.plot, main = dimnames(PF())[[1]][S], cex.main= 1.5, col = participant.colors, cex=3.2,pch = 21,bg=fill.colors)\n                points(bound.mat, type = \"l\", lty = 1, lwd = 1, col = \"grey70\")\n                text(to.plot, labels = rownames(t(PF()[S, , ])))\n              })\n            })\n          }\n        })\n        #Back clicking = return on the \"all\" plot.\n        observeEvent(input$BackClick2, {\n          updateSelectInput(session, \"selectSpecies\", selected = \"all\")\n        })\n\n        #Update the text zone with outliers detected:\n        #outgn\n        output$outputPhylter1 <- renderText ({\n          if(length(outgn()) != 0){\n            gn = paste(outgn(), \";\")\n            append (gn, \"outlier genes: \", after=0)\n          }\n          else{\n            \"no outlier gene detected\"\n          }\n        })\n        #sp\n        output$outputPhylter2 <- renderText ({\n          if(length(outsp()) != 0){\n            sp=paste(outsp(), \";\")\n            append (sp, \"outlier species: \", after=0)\n          }\n          else{\n            \"no outlier species detected\"\n          }\n\n        })\n        #cell\n        output$outputPhylter3 <- renderText ({\n          if(!is.null(outcell()) && nrow(outcell()) != 0){\n            ce = paste(outcell()[,1],outcell()[,2], \";\")\n            append (ce, \"outlier gene/species: \", after=0)\n          }\n          else{\n            \"no outlier cell detected\"\n          }\n        })\n    #visualize genes: genes are red if outliers, grey if not\n      output$plot3 <- renderPlot({\n        withProgress(message = 'Making plot', value = 0, {\n        participant.colors <- rownames(G())\n        if (length(outgn()) != 0){\n          for (j in 1:length(outgn())){\n            participant.colors[which(participant.colors == outgn()[j])] = \"red1\"\n          }\n          participant.colors[which(participant.colors != \"red1\")] = \"grey50\"\n        }\n        else{\n          participant.colors = \"grey50\"\n        }\n        plot(G(), col = participant.colors, cex = 3.5)\n        text(G(), labels = rownames(G()))\n        })\n      })\n    }\n\n      ##event = DETECTION OUTLIER OFF\n    else{\n\n      output$DataSetProblem <- renderText({\n        \"\"\n      })\n\n      ##Visualize some trees tab. We can type several trees in the box \"Sumit trees\", all separated by a \"-\" and trees are ploted.\n      observeEvent(input$SumitTrees,{\n        List = TreesList()\n        S = strsplit(List, \",\")\n        S = S[[1]]\n        output$plot1 <- renderPlot(height = 500*length(S),{\n          withProgress(message = 'Making plot', value = 0, {\n            if (length(S) == 1){par(mfrow = c(1,1))}\n            if (length(S) >= 2 && length(S) <= 8){par(mfrow = c(ceiling(length(S)/2),2))}\n            if (length(S) > 8 && length(S) <= 30){par(mfrow = c(ceiling(length(S)/5),5))}\n            if (length(S) > 30){par(mfrow = c(ceiling(length(S)/8),8))}\n            par(mar = c(0,0,1,0))\n            for (i in 1:length(S)){\n              incProgress(1/length(S))\n              ape::plot.phylo(trees()[[S[i]]], main = S[i])\n            }\n          })\n        })\n      })\n\n      ##Observe species:\n      observe({\n        updateSelectInput(session, \"selectSpecies\", selected= \"all\", choices = append(append(outVar(),\"mean\",after=0),\"all\", after=0))\n      })\n      observeEvent(input$selectSpecies, {\n        S=input$selectSpecies\n        #all species in differents plots. All in the same scale.\n        if (S == \"all\"){\n          output$plot2 <- renderPlot(height = PlotHeight(),{\n            withProgress(message = 'Making plot', value = 0, {\n              par(mfrow=c(ceiling(length(outVar())/4),4))\n              par(mar=c(2,2,2,2))\n              part.design <- diag(dim(PF())[3])\n              participant.colors <- \"grey70\"\n              for (sp in 1:length(outVar())){\n                incProgress(1/length(outVar()))\n                to.plot <- t(PF()[sp, , ])\n                center.point <- FS()[sp, c(1, 2)]\n                center.rep <- matrix(center.point, dim(PF())[3], 2, byrow = TRUE)\n                bound.mat <- rbind(center.rep, to.plot[, c(1, 2)])\n                bound.mat <- bound.mat[as.vector(t(matrix(seq(1, nrow(bound.mat)), ncol = 2))), ]\n                plot(to.plot, main = dimnames(PF())[[1]][sp], cex.main= 1.5, col = participant.colors, cex=3.2, xlim = range(t(PF()[, 1, ])), ylim = range(t(PF()[, 2, ])))\n                points(bound.mat, type = \"l\", lty = 1, lwd = 1, col = \"grey70\")\n                text(to.plot, labels = rownames(t(PF()[sp, , ])))\n              }\n            })\n          })\n        }\n        #mean position of each species on a graph\n        if(S == \"mean\"){\n          output$plot2 <- renderPlot({\n            withProgress(message = 'Making plot', value = 0, {\n              incProgress(0)\n              item.design <- diag(dim(FS())[1])\n              item.colors <- \"grey70\"\n              real.minimum <- min(FS())\n              real.maximum <- max(FS())\n              real.value <- max(c(abs(real.minimum), abs(real.maximum)))\n              plot(FS(), col = item.colors,axes=F, cex = 3.5, ylim=c(-real.value, real.value), xlim=c(-real.value, real.value))\n              axis(1, pos=0,lwd.ticks=0.5)\n              axis(2, pos=0,lwd.ticks=0.5)\n              text(FS(), rownames(FS()))\n            })\n          })\n        }\n        #single species selected\n        if(S != \"mean\" && S != \"all\"){\n          output$plot2 <- renderPlot({\n            withProgress(message = 'Making plot', value = 0, {\n              incProgress(0)\n              part.design <- diag(dim(PF())[3])\n              #participant.colors <- as.matrix(createColorVectorsByDesign(part.design)$oc)\n              participant.colors <- \"grey70\"\n              to.plot <- t(PF()[S, , ])\n              center.point <- FS()[S, c(1, 2)]\n              center.rep <- matrix(center.point, dim(PF())[3], 2, byrow = TRUE)\n              bound.mat <- rbind(center.rep, to.plot[, c(1, 2)])\n              bound.mat <- bound.mat[as.vector(t(matrix(seq(1, nrow(bound.mat)), ncol = 2))), ]\n              plot(to.plot, main = dimnames(PF())[[1]][S], cex.main = 1.5, col = participant.colors, cex = 3.2)\n              points(bound.mat, type = \"l\", lty = 1, lwd = 1, col = \"grey70\")\n              text(to.plot, labels = rownames(t(PF()[S, , ])))\n            })\n          })\n        }\n      })\n      #Back clicking = return on the \"all\" plot.\n      observeEvent(input$BackClick2, {\n        updateSelectInput(session, \"selectSpecies\", selected = \"all\")\n      })\n      #update outliers text to blank\n      output$outputPhylter1 <- renderText ({\n        \"\"\n      })\n        output$outputPhylter2 <- renderText ({\n        \"\"\n      })\n      output$outputPhylter3 <- renderText ({\n        \"\"\n      })\n      #visualize genes : all genes are greys\n      output$plot3 <- renderPlot({\n        withProgress(message = 'Making plot', value = 0, {\n        incProgress(1)\n        participant.colors = \"grey50\"\n        plot(G(), col = participant.colors, cex = 3.5)\n        text(G(), labels = rownames(G()))\n        })\n      })\n    }\n  })\n\n#Evenements indépendant de la détection d'outliers\n    ##Visualize the 2WR matrix\n   output$plot8 <- renderPlot({\n      reorder_cormat <- function(cormat){\n        # Utiliser la corrélation entre les variables\n        # comme mésure de distance\n        dd <- as.dist((1 - cormat) / 2)\n        hc <- hclust(dd)\n        cormat <- cormat[hc$order, hc$order]\n      }\n      get_upper_tri <- function(cormat){\n        cormat[lower.tri(cormat)] <- NA\n        return(cormat)\n      }\n      withProgress(message = 'Making correlation plot', value = 0, {\n        incProgress(1)\n        rcC <- reorder_cormat(C())\n        upper_tri <- get_upper_tri(rcC)\n        melted_cormat <- melt(rcC, na.rm = TRUE)\n        #parfois 1 = 1,0000000000001 et ça ne rentre pas dans le gradient donc :\n        melted_cormat$value[melted_cormat$value > 1] <- 1\n        # Créer un ggheatmap\n        ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = as.numeric(value))) + xlab(\"\") + ylab(\"\")\n        ggheatmap <- ggheatmap + geom_tile()\n        ggheatmap <- ggheatmap + scale_fill_gradient2(low = \"white\", high = \"red\", mid = \"yellow\", midpoint = 0.5, limit = c(0,1), space = \"Lab\", name=\"correlation\")+ theme_minimal()  # minimal theme\n        ggheatmap <- ggheatmap + theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 10, hjust = 1))\n        ggheatmap <- ggheatmap + coord_fixed()\n\n        # Afficher heatmap\n       ggheatmap + coord_cartesian(xlim = ranges$x, ylim = ranges$y, expand = FALSE)\n      })\n   })\n\n    output$plot4 <- renderPlot({\n      withProgress(message = 'Making plot', value = 0, {\n        incProgress(1)\n        WR <- WR()\n        pl = plot2WR(WR)\n        pl + coord_cartesian(xlim = ranges$x, ylim = ranges$y, expand = FALSE)\n      })\n    })\n    #zoom on 2WR matrix\n    observeEvent(input$plot4dbclick, {\n      brush <- input$plot4_brush\n      if (!is.null(brush)) {\n        ranges$x <- c(brush$xmin, brush$xmax)\n        ranges$y <- c(brush$ymin, brush$ymax)\n      } else {\n        ranges$x <- NULL\n        ranges$y <- NULL\n      }\n    })\n    #zoom on 2WR matrix\n    observeEvent(input$plot8dbclick, {\n      brush <- input$plot8_brush\n      if (!is.null(brush)) {\n        ranges$x <- c(brush$xmin, brush$xmax)\n        ranges$y <- c(brush$ymin, brush$ymax)\n      } else {\n        ranges$x <- NULL\n        ranges$y <- NULL\n      }\n    })\n\n    ###VISUALIZE SPECIES\n    output$plot6 <- renderPlot(height = 70 *length(outVar()), {\n      withProgress(message = 'Making plot', value = 0, { \n        TAB <- mat()\n        nam <- rownames(TAB[[1]])\n        # TAB<-lapply(TAB, function(x,y) x[y,y],y=nam)\n        listx = vector()\n        listy = vector()\n        # All species are vizualized on 5 column\n        par(mfrow = c(ceiling(length(nam)/5),5))\n        par(mar = c(1,1,1,1))\n        par(oma = c(0,0,0,0))\n        for (j in 1:length(nam)) {\n          GENEi<-NULL\n          SP <- nam[j]\n          T1 <- lapply(TAB, function(x) (x[SP,nam]))\n          T1m<-matrix(unlist(T1), nrow=length(trees()), byrow=TRUE)\n          Means.T1m<-apply(T1m, 2, mean)\n          alphas<-seq(0,2*pi,length.out=length(nam)+1)\n          alphas<-alphas[1:length(nam)]\n          for (i in 1:length(trees())) {\n            genei<-T1m[i,]/Means.T1m\n            genei[is.na(genei)]<-1\n            GENEi<-c(GENEi, genei)\n            x<-genei*cos(alphas)\n            y<-genei*sin(alphas)\n            x[is.na(x)]<-0\n            y[is.na(y)]<-0\n            listx = append(listx,x)\n            listy = append(listy,y)\n          }\n        }\n        for (j in 1:length(nam)) {\n          incProgress(1/length(nam))\n          SP<-nam[j]\n          GENEi<-NULL\n          T1<-lapply(TAB, function(x) (x[SP,nam]))\n          T1m<-matrix(unlist(T1), nrow=length(trees()), byrow=TRUE)\n          ##T1m gives 1 plot corresponding to \"Kla\" for each gene.\n          Means.T1m<-apply(T1m, 2, mean)\n          ##we check angles\n          alphas<-seq(0,2*pi,length.out=length(nam)+1)\n          alphas<-alphas[1:length(nam)]\n          ##CIRCLE:\n          xc<-rep(1,length(nam)+1)*cos(seq(0,2*pi,length.out=length(nam)+1))\n          yc<-rep(1,length(nam)+1)*sin(seq(0,2*pi,length.out=length(nam)+1))\n          ##we check angles\n          xc<-xc[1:length(nam)]\n          yc<-yc[1:length(nam)]\n          ##for each gene, the ray is given by the proportion:\n          plot((max(abs(listx)) / max(xc)) * xc, (max(abs(listy)) / max(yc)) * yc, type=\"n\", xlim = c(-max(abs(listx)) - 2, max(abs(listx)) + 2), ylim = c(-max(abs(listy)) - 2, max(abs(listy)) + 2), frame.plot=FALSE, axes = FALSE, xlab = \"\", ylab = \"\")\n          text((max(abs(listx)) / max(xc)) * xc,(max(abs(listy)) / max(yc)) * yc, labels = nam, col = \"light grey\")\n          for (i in 1:length(trees())) {\n            genei <- T1m[i,] / Means.T1m\n            genei[is.na(genei)] <- 1\n            GENEi <- c(GENEi, genei)\n            x <- genei * cos(alphas)\n            y <- genei * sin(alphas)\n            x[is.na(x)] <- 0\n            y[is.na(y)] <- 0\n            polygon(xc, yc, border = \"light grey\", lwd = 0.54)\n            polygon(x, y, border = \"red\", lwd = 0.8)\n            text(-max(max(abs(listx)) / max(xc) * xc), -max(max(abs(listy)) / max(yc) * yc), SP, cex = 2)\n          }\n        }\n      })\n    })\n    ####Visialize distance by genes\n    output$plot7 <- renderPlot({\n      if (Geneslist() != \"\"){\n        withProgress(message = 'Making plot', value = 0, {\n          ##Update Genetrees. Genelist from the panel \"visualize distances between genes\". Genes are spilts in partition of 30 genes\n          Geneslist = as.character(Geneslist())\n          Geneslist = strsplit(Geneslist, \"-\")\n          TAB <- mat()\n          nam <- rownames(TAB[[1]])\n          #TAB<-lapply(TAB, function(x,y) x[y,y],y=nam)\n          par(mfrow = c(5, 6))\n          par(mar = c(0, 0, 0, 0))\n          par(oma = c(0, 0, 0, 0))\n          #i1 and i2 are the window of genes ploted in the tab. It corresponds to the number selected in the selectinput.\n          i1 = as.integer(Geneslist[[1]][1])\n          i2 = as.integer(Geneslist[[1]][2])\n          listx = vector()\n          listy = vector()\n          for (i in i1:i2) {\n            for (j in 1:length(nam)) { ##for each speciew\n              SP <- nam[j]\n              T1 <- lapply(TAB, function(x, y) (x[SP, nam]))\n              T1m <- matrix(unlist(T1), nrow = length(trees()), byrow = TRUE)\n              Means.T1m <- apply(T1m, 2, mean)\n              genei <- T1m[i,] / Means.T1m\n              alphas <- seq(0,2 * pi,length.out = length(nam)+1)\n              alphas <- alphas[1:length(nam)]\n              x <- genei * cos(alphas)\n              y <- genei * sin(alphas)\n              x[is.na(x)] <- 0\n              y[is.na(y)] <- 0\n              listx = append(listx, x)\n              listy = append(listy, y)\n            }\n          }\n          for (i in i1:i2) {\n            incProgress(1/length(Geneslist()))\n            plot(0,0,type = \"n\", xlim = c(-max(abs(listx)) - 2, max(abs(listx)) + 2), ylim = c(-max(abs(listy)) - 2, max(abs(listy)) + 2), frame.plot=FALSE, axes=FALSE, xlab=\"\", ylab=\"\", col.main=\"black\", cex.main = 1.5)\n            title(i,line = -5)\n            for (j in 1:length(nam)) { ##for each speciew\n              SP <- nam[j]\n              T1 <- lapply(TAB, function(x, y) (x[SP, nam]))\n              T1m <- matrix(unlist(T1), nrow = length(trees()), byrow = TRUE)\n              Means.T1m <- apply(T1m, 2, mean)\n              genei <- T1m[i,] / Means.T1m\n              xc <- rep(1, length(nam) + 1) * cos(seq(0,2 * pi,length.out = length(nam) + 1))\n              yc <- rep(1, length(nam) + 1) * sin(seq(0,2 * pi,length.out = length(nam) + 1))\n              ##we check angles\n              alphas <- seq(0, 2*pi,length.out = length(nam) + 1)\n              alphas <- alphas[1:length(nam)]\n              x <- genei * cos(alphas)\n              y <- genei * sin(alphas)\n              x[is.na(x)] <- xc[j]\n              y[is.na(y)] <- yc[j]\n              polygon(xc,yc, border = \"light grey\", lwd = 0.5)\n              points(x, y, pch = 19, cex=0.2, col = \"red\")\n              polygon(x, y, border = \"red\", lwd = 0.1)\n            }\n          }\n        })\n      }\n    })\n  })\n}\n",
    "created" : 1499069006442.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1725191937",
    "id" : "C9667162",
    "lastKnownWriteTime" : 1499870834,
    "last_content_update" : 1499870834699,
    "path" : "/media/aurore/KINGSTON/stageLBBE/PHYLTER/Phylter/shiny/PhylteR/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}