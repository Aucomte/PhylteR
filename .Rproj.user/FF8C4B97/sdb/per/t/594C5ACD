{
    "collab_server" : "",
    "contents" : "# trees2matrices changes a list of trees into a list of matrices\n\ntrees2matrices <- function(trees, distance = \"patristic\", bvalue = 0) {\n  correction <- function(mat){\n    for (i in 1:nrow(mat)){\n      for (j in 1:ncol(mat)){\n        if (i != j) {mat[i,j] <- mat[i,j] - 1}\n      }\n    }\n    return(mat)\n  }\n  list.trees <- list()\n  for (i in 1:length(trees)) {\n    tree <- trees[[i]]\n    if (distance == \"nodal\") {\n      if (bvalue != 0) {\n        if (!is.null(tree$node.label)) {\n          l <- 1:Nnode(tree)\n          indices.nodes <- l[as.numeric(tree$node.label) < bvalue] + Ntip(tree)\n          if (length(indices.nodes) > 0) {\n            for (j in 1:length(indices.nodes)) {\n              tree$edge.length[tree$edge[,1] == indices.nodes[j]] <- 1e-10\n            }\n          }\n          tree <- di2multi(tree, tol = 1e-9)\n        }\n        else {\n          #tree <- di2multi(tree, tol = bvalue)\n          cat (\"-------- ATTENTION!! There are no bootstraps values in your trees or your bvalue parameter does not correspond values in your trees ! -------\")\n        }\n      }\n      tree.brlen <- compute.brlen(tree, 1)\n    }\n    else if (distance == \"patristic\") {\n      if (bvalue != 0) {\n        if (!is.null(tree$node.label)) {\n          l <- 1:Nnode(tree)\n          indices.nodes <- l[as.numeric(tree$node.label) < bvalue] + Ntip(tree)\n          if (length(indices.nodes) > 0) {\n            for (j in 1:length(indices.nodes)) {\n              tree$edge.length[tree$edge[,1] == indices.nodes[j]] <- 1e-10\n            }\n          }\n          tree <- di2multi(tree, tol = 1e-9)\n        }\n        else {\n          #tree <- di2multi(tree, tol = bvalue)\n          cat (\"-------- ATTENTION!! There are no bootstraps values in your trees ! -------\")\n        }\n      }\n      tree.brlen <- tree\n    }\n    list.trees[[i]] <- tree.brlen\n  }\n  TRS <- lapply(list.trees, cophenetic)\n  if (distance == \"nodal\"){\n    TRS <- lapply(TRS, correction)\n  }\n  if (!is.null(names(trees))) {\n    names(TRS) <- names(trees)\n  }\n  return(TRS)\n}\n\n# this function permits the user to add gene names (as list) to the trees. If no names is given, genes are numeroted from 1 to the number of genes.\n\nrename.genes <- function(trees, gene.names = NULL) {\n  if(!is.null(gene.names)) {\n    names(trees) <- gene.names\n  } else {\n    if(is.null(names(trees))) {\n      names(trees) <- as.character(c(1:length(trees)))\n    }\n  }\n  return(trees)\n}\n\n# mat2Dist applies distatis on a list of distance matrices\n\nmat2Dist <- function(matrices, Norm = \"NONE\") {\n  # transform the list of matrices to a cube\n  row <- rownames(matrices[[1]])\n  for (i in 1:length(matrices)) {\n    matrices[[i]] <- matrices[[i]][row, row]\n  }\n  genesNumber <- length(matrices)\n  speciesNumber <- nrow(matrices[[genesNumber]])\n  TheVeryBigCube <- array(0, c(speciesNumber, speciesNumber, genesNumber))\n  for (i in 1:genesNumber) {\n    TheVeryBigCube[, , i] <- matrices[[i]]\n  }\n  rownames(TheVeryBigCube) <- rownames(matrices[[1]])\n  colnames(TheVeryBigCube) <- colnames(matrices[[1]])\n  # Apply distatis on the cube and keep genes names in distatis results\n  Distatis <- distatis(TheVeryBigCube, Norm = Norm)\n  dimnames(Distatis$res4Splus$PartialF)[[3]] <- names(matrices)\n  return(Distatis)\n}\n\n# Imputing missing data in matrices with missMDA package\n\nimpPCA.multi <- function(matrices, ncp = 3, center = FALSE, scale = FALSE, maxiter = 1000) {\n  geneNames <- list()\n  # Create a matrix with every species to fill : GrandeMatrice\n  species<-unique(unlist(lapply(matrices, rownames)))\n  nbsp<-length(species) #ca Ã©vite de le recalculer plein de fois.\n  grandeMatrice=matrix(nrow = length(species), ncol = nbsp)\n  rownames(grandeMatrice) = species\n  colnames(grandeMatrice) = species\n  # Create a list of matrices names with missing data\n  dimMat<-unlist(lapply(matrices, nrow))\n  geneNames<-names(which(dimMat<nbsp))\n  matrices2 = matrices\n  if (length(geneNames) != 0) {\n    # For each matrix with missing data, we fill the GrandeMatrice\n    for (i in 1:length(geneNames)) {\n      row <- rownames(matrices2[[geneNames[[i]]]])\n      grandeMatrice2 <- grandeMatrice\n      grandeMatrice2[row, row] <- matrices2[[geneNames[[i]]]][row,row]\n      matrices2[[geneNames[[i]]]] <- grandeMatrice2\n    }\n    matrices3 <- matrices2\n    row <- rownames(matrices2[[1]])\n    for (i in 1:length(matrices2)) {\n      matrices3[[i]] <- as.vector(matrices2[[i]][row, row][upper.tri(matrices2[[i]][row, row])])\n    }\n    mat <- do.call(cbind,matrices3)\n    # estimating missing data\n    matIPCA <- imputePCA2(mat, center = center, scale = scale, maxiter = maxiter)\n    matIPCA <- matIPCA$completeObs\n    matricesFT <- list()\n    for (i in 1:length(matrices2)) {\n      matrices[[i]] <- matrix(nrow = length(row), ncol = length(row))\n      rownames(matrices[[i]]) <- row\n      colnames(matrices[[i]]) <- row\n      data=as.vector(matIPCA[, i])\n      matrices[[i]][upper.tri(matrices2[[i]])] <- data\n      matricesFT[[i]] <- t(matrices[[i]])\n      matrices[[i]][lower.tri(matrices2[[i]])] <- matricesFT[[i]][lower.tri(matrices2[[i]])]\n      for (j in 1:ncol(matrices[[i]])) {\n        matrices[[i]][j, j] <- 0\n      }\n    }\n  }\n  return(matrices)\n}\n\n# imputePCA2 function from missMDA package but with the possibility to not center the data. And with no negative values possibly imputed.\n\nimputePCA2 <- function (X, ncp = 2, center = FALSE, scale = FALSE, method = c(\"Regularized\", \"EM\"), row.w = NULL, coeff.ridge = 1, threshold = 1e-6, seed = NULL,nb.init = 1, maxiter = 1000) {\n  impute <- function (X, ncp = 4, center = FALSE, scale = FALSE, method = NULL, threshold = 1e-6,seed = NULL, init = 1, maxiter = 1000, row.w = NULL, coeff.ridge = 1) {\n    moy.p <- function(V, poids) {\n      res <- sum(V * poids, na.rm = TRUE) / sum(poids[!is.na(V)])\n    }\n    ec <- function(V, poids) {\n      res <- sqrt(sum(V ^ 2 * poids,na.rm = TRUE) / sum(poids[!is.na(V)]))\n    }\n    nb.iter <- 1\n    old <- Inf\n    objective <- 0\n    if (!is.null(seed)) {\n      set.seed(seed)\n      }\n    X <- as.matrix(X)\n    ncp <- min(ncp, ncol(X), nrow(X) - 1)\n    missing <- which(is.na(X))\n    mean.p <- apply(X, 2, moy.p, row.w)\n    if (center != TRUE){\n      mean.p <- rep(0, ncol(X))\n    }\n    Xhat <- t(t(X) - mean.p)\n    et <- apply(Xhat, 2, ec, row.w)\n    if (scale) Xhat <- t(t(Xhat) / et)\n    if (any(is.na(X))) Xhat[missing] <- 0\n    if (init > 1) Xhat[missing] <- rnorm(length(missing)) # random initialization\n    fittedX <- Xhat\n    if (ncp == 0) nb.iter = 0\n    while (nb.iter > 0) {\n      Xhat[missing] <- fittedX[missing]\n      if (scale) Xhat = t(t(Xhat) * et)\n      Xhat <- t(t(Xhat) + mean.p)\n      if (center == TRUE){\n        mean.p <- apply(Xhat, 2, moy.p, row.w)\n      }\n      Xhat <- t(t(Xhat) - mean.p)\n      et <- apply(Xhat, 2, ec, row.w)\n      if (scale) Xhat <- t(t(Xhat) / et)\n      svd.res <- svd.triplet(Xhat, row.w = row.w, ncp = ncp)\n      sigma2  <- nrow(X) * ncol(X) / min(ncol(X), nrow(X)-1) * sum((svd.res$vs[-c(1:ncp)] ^ 2) / ((nrow(X) - 1) * ncol(X) - (nrow(X) - 1) * ncp - ncol(X) * ncp + ncp ^ 2))\n      sigma2 <- min(sigma2 * coeff.ridge, svd.res$vs[ncp + 1] ^ 2)\n      if (method == \"em\") sigma2 <-0\n      lambda.shrinked = (svd.res$vs[1:ncp] ^ 2 - sigma2) / svd.res$vs[1:ncp]\n      fittedX = tcrossprod(t(t(svd.res$U[, 1:ncp, drop = FALSE] * row.w) * lambda.shrinked), svd.res$V[, 1:ncp, drop = FALSE])\n      fittedX <- fittedX / row.w\n      # No negative value\n      fittedX[fittedX < 0] = 0\n      diff <- Xhat-fittedX\n      diff[missing] <- 0\n      objective <- sum(diff ^ 2 * row.w)\n      criterion <- abs(1 - objective / old)\n      old <- objective\n      nb.iter <- nb.iter + 1\n      if (!is.nan(criterion)) {\n        if ((criterion < threshold) && (nb.iter > 5)) nb.iter <- 0\n        if ((objective < threshold) && (nb.iter > 5)) nb.iter <- 0\n      }\n      if (nb.iter > maxiter) {\n        nb.iter <- 0\n        warning(paste(\"Stopped after \", maxiter, \" iterations\"))\n      }\n    }\n    if (scale) Xhat <- t(t(Xhat) * et)\n    Xhat <- t(t(Xhat) + mean.p)\n    completeObs <- X\n    completeObs[missing] <- Xhat[missing]\n    if (scale) fittedX <- t(t(fittedX) * et)\n    fittedX <- t(t(fittedX) + mean.p)\n\n    result <- list()\n    result$completeObs <- completeObs\n    result$fittedX <- fittedX\n    return(result)\n  }\n  # Main program\n  method <- match.arg(method, c(\"Regularized\", \"regularized\", \"EM\", \"em\"), several.ok = T)[1]\n  obj = Inf\n  method <- tolower(method)\n  if (ncp > min(nrow(X) - 2, ncol(X) - 1)) stop(\"ncp is too large\")\n  if (is.null(row.w)) row.w = rep(1, nrow(X)) / nrow(X)\n  for (i in 1:nb.init){\n    if (!any(is.na(X))) return(X)\n    res.impute = impute(X, ncp = ncp, scale = scale,center = center, method = method, threshold = threshold, seed = if(!is.null(seed)){(seed * (i - 1))}else{NULL}, init = i, maxiter = maxiter, row.w = row.w, coeff.ridge = coeff.ridge)\n    if (mean((res.impute$fittedX[!is.na(X)] - X[!is.na(X)]) ^ 2) < obj) {\n      res <- res.impute\n      obj <- mean((res.impute$fittedX[!is.na(X)] - X[!is.na(X)]) ^ 2)\n    }\n  }\n  return(res)\n}\n\n# Impute Missing datas by means\nimpMean <- function(matrices) {\n  qual <- 0\n  listsp <- colnames(matrices[[1]])\n  for (i in 2:length(matrices)) {\n    listsp <- union(listsp, colnames(matrices[[i]]))\n  }\n  length.indiv <- unlist(lapply(lapply(matrices, colnames), length))\n  tmp <- rep(1,length(length.indiv))\n  testqual <- tmp[(length.indiv == length(listsp)) == FALSE]\n  if (length(testqual) > 0) qual <- 1\n  if (qual == 1) {\n    listsp <- colnames(matrices[[1]])\n    for (i in 2:length(matrices)) {\n      listsp <- union(listsp, colnames(matrices[[i]]))\n    }\n    newcol <- list()\n    for (i in 1:length(matrices)) {\n      ##print(i)\n      newcol[[i]] <- setdiff(listsp, colnames(matrices[[i]]))\n      matrices[[i]] <- cbind(matrices[[i]], matrix(ncol = length(newcol[[i]]), nrow=nrow(matrices[[i]]), dimnames = list(colnames(matrices[[i]]), newcol[[i]])))\n      matrices[[i]]<-rbind(matrices[[i]], matrix(ncol = ncol(matrices[[i]]), nrow = length(newcol[[i]]), dimnames = list(newcol[[i]], colnames(matrices[[i]]))))\n    }\n  }\n  mat1 <- matrices[[1]]\n  species1 <- row.names(mat1)\n  len2 <- length(species1)\n  ALL <- list()\n  ALL[[1]] <- mat1\n  for(i in 2:length(matrices)){\n    mati <- matrices[[i]]\n    speciesi <- row.names(mati)\n    indice <- (1:len2)[species1[1] == speciesi]\n    for(j in 2:len2){\n      indice[j] <- (1:len2)[species1[j] == speciesi]\n    }\n    mati <- mati[indice, ]\n    mati <- mati[, indice]\n    ALL[[i]] <- mati\n  }\n  if (qual == 1) {\n    TEST <- unlist(ALL)\n    nbcase <- nrow(ALL[[1]]) * nrow(ALL[[1]])\n    Nbt <- length(ALL)\n    allcase <- 0:(Nbt - 1)\n    MEANS <- array()\n    for (i in 1:nbcase) {\n      MEANS[i] <- mean(TEST[i + allcase * nbcase], na.rm = TRUE)\n    }\n    MEANMAT <- matrix(MEANS,nrow = nrow(ALL[[1]]), ncol = ncol(ALL[[1]]))\n    rownames(MEANMAT) <- colnames(MEANMAT) <- colnames(ALL[[1]])\n    MEANMAT[is.na(MEANMAT)] <- mean(MEANMAT, na.rm = TRUE)\n    for (i in 1:length(ALL)) {\n      if (length(newcol[[i]]) > 0) {\n        ALL[[i]][ ,newcol[[i]]] <- MEANMAT[ ,newcol[[i]]]\n        ALL[[i]][newcol[[i]], ] <- MEANMAT[newcol[[i]], ]\n      }\n    }\n  }\n  names(ALL) = names(matrices)\n  return(ALL)\n}\n\n# create 2WR matrix from distatis results\n\nDist2WR <- function(Distatis) {\n  matrixWR2 <- matrix(nrow = dim(Distatis$res4Splus$PartialF)[[1]], ncol = dim(Distatis$res4Splus$PartialF)[[3]])\n  colnames(matrixWR2) <- dimnames(Distatis$res4Splus$PartialF)[[3]]\n  rownames(matrixWR2) <- dimnames(Distatis$res4Splus$PartialF)[[1]]\n\n  for (i in 1:length(dimnames(Distatis$res4Splus$PartialF)[[3]])){\n    for (j in 1:length(dimnames(Distatis$res4Splus$PartialF)[[1]])){\n      x <- (Distatis$res4Splus$PartialF[dimnames(Distatis$res4Splus$PartialF)[[1]][j], , dimnames(Distatis$res4Splus$PartialF)[[3]][i]] - Distatis$res4Splus$F[dimnames(Distatis$res4Splus$PartialF)[[1]][j], ]) ^ 2\n      matrixWR2[dimnames(Distatis$res4Splus$PartialF)[[1]][j], dimnames(Distatis$res4Splus$PartialF)[[3]][i]] <- sqrt(sum(x))\n    }\n  }\n  return(matrixWR2)\n}\n\n# Suppress complete outiers (species or genes) in trees in order to detect cell outliers in a second time.\n# Fonction from phylo_MCOA slitly modified to fit our method.\n\nrm.gene.and.species <- function(trees, sp2rm, gn2rm) {\n  gene.names <- list()\n  for (i in 1:length(labels(trees))) {\n    gene.names[i] <- labels(trees)[i]\n  }\n  if (length(sp2rm) > 0) {\n    for (i in 1:length(trees)) {\n      sp <- trees[[i]]$tip.label\n      toremove <- intersect(sp, sp2rm)\n      trees[[i]] <- drop.tip(trees[[i]], toremove)\n    }\n  }\n  if (length(gn2rm) > 0) {\n    genes2keep <- setdiff(gene.names, gn2rm)\n    trees2 <- list()\n    j <- 0\n    for (i in 1:length(trees)) {\n      if (is.element(gene.names[i], genes2keep)) {\n        j <- j + 1\n        trees2[[j]] <- trees[[i]]\n      }\n    }\n    names(trees2) <- genes2keep\n  } else {\n    trees2 <- trees\n  }\n  return(trees2)\n}\n\n# Phylter Function to detect complete and cell outliers from a list of trees\n\nPhylteR <- function(trees, distance = \"patristic\", bvalue = 0, method.imp = \"IPCA\", ncp = 3, center = FALSE, scale = FALSE, maxiter = 1000, k = 1.5, thres = 0.5, gene.names = NULL, Norm = \"NONE\") {\n  if (is.list(trees)) {\n    if (class(trees[[1]]) != \"phylo\") stop (\"The trees should be in the \\\"phylo\\\" format!\")\n  }\n  if (class(trees) == \"character\") {\n    trees <- read.tree(trees)\n  }\n  if (!is.null(gene.names) && length(gene.names) != length(trees)) stop (\"The number of gene names and the number of trees differ!\")\n  ##check for duplications\n  check.dup <- lapply(trees, function(x) {x$tip.label[duplicated(x$tip.label)]})\n  if (sum(unlist(lapply(check.dup, length))) > 0) {\n    cat (\"-------- ATTENTION!! There are some duplicated species in some of your trees: -------\")\n    for (w in 1:length(trees)) {\n      if (length(check.dup[[w]]) > 0) cat(paste(\"\\n     - Species \", check.dup[[w]], \" present more than once in tree \", w, \"\\n\\n\", sep=\"\"))\n    }\n    stop (\"Remove or rename duplicated species and try again.\\n\\n\", call.=FALSE)\n  }\n  trees <- rename.genes(trees, gene.names = gene.names)\n  RES <- NULL\n  matrices <- trees2matrices(trees, distance = distance, bvalue = bvalue)\n\n  if (method.imp == \"IPCA\"){\n    matrices <- impPCA.multi(matrices, ncp = ncp, center = center, scale = scale, maxiter = maxiter)\n  }\n  else if (method.imp == \"MEAN\"){\n    matrices <- impMean(matrices)\n  }\n  else{\n    stop (\"You should choose an imputation method : MEAN or IPCA\")\n  }\n  Dist <- mat2Dist(matrices, Norm = Norm)\n  WR <- Dist2WR(Dist)\n  CompOutl <- detect.complete.outliers(WR, k = k, thres = thres)\n  if (length(CompOutl$outsp) > 0 || length(CompOutl$outgn) > 0) {\n    TREESwithoutCompleteOutlierDist <- rm.gene.and.species(trees, CompOutl$outsp, CompOutl$outgn)\n    matrices2 <- trees2matrices(TREESwithoutCompleteOutlierDist, distance = distance, bvalue = bvalue)\n    if (method.imp == \"IPCA\"){\n      matrices2 <- impPCA.multi(matrices2, ncp = ncp, center = center, scale = scale, maxiter = maxiter)\n    }\n    else if (method.imp == \"MEAN\"){\n      matrices2 <- impMean(matrices2)\n    }\n    Dist2 <- mat2Dist(matrices2, Norm = Norm)\n    WR2 <- Dist2WR(Dist2)\n    CellOutl2 <- detect.cell.outliers(WR2, k = k)\n    RES$Complete <- CompOutl\n    RES$CellByCell <- CellOutl2\n  } else {\n    CellOutl2 <- detect.cell.outliers(WR,  k = k)\n    RES$Complete <- CompOutl\n    RES$CellByCell <- CellOutl2\n  }\n  return(RES)\n}\n\n#This function normalizes the 2WR matrix (or any matrix) according to the species (rows) or to the genes (columns).\n\nnormalize <- function(mat, what = \"none\") {\n  if (what == \"species\") mat <- apply(mat, 2, function(x) {x / mean(x)})\n  else if (what == \"genes\") mat <- t(apply(mat, 1, function(x) {x / mean(x)}))\n  else if (what == \"none\") {\n    mat <- mat\n    #cat(\"The matric is unchanged.\\n\")\n  } else print (\"WARNING! Error in the kind of scaling you want! No scaling applied.\")\n  return(mat)\n}\n\n# Detection of complete outliers from phylo-mcoa\ndetect.complete.outliers <- function(mat2WR, k = 1.5, thres = 0.5) {\n  outl.sub <- function(x, k) {\n    return(x > quantile(x)[4] + k * IQR(x) + 1e-10)\n    ##note: the 1e-10 ,is because when all values are similar except one, the first one is considered as equal to the third quartile... May be a bug in quantile function?\n  }\n  tabgn <- normalize(mat2WR, \"genes\")\n  tabgn.TF <- t(apply(tabgn, 1, outl.sub, k = k))\n  tabsp <- normalize(mat2WR, \"species\")\n  tabsp.TF <- apply(tabsp,2, outl.sub, k = k)\n  tabgn.TF[tabgn.TF == FALSE] <- 0\n  tabgn.TF[tabgn.TF == TRUE] <- 1\n  tabsp.TF[tabsp.TF == FALSE] <- 0\n  tabsp.TF[tabsp.TF == TRUE] <- 1\n  score.genes <- apply(tabgn.TF, 2, function(x) {sum(x) / length(x)})\n  score.species <- apply(tabsp.TF, 1, function(x) {sum(x) / length(x)})\n  out.genes <- names(score.genes)[score.genes > thres]\n  out.species <- names(score.species)[score.species > thres]\n  RES <- NULL\n  RES$mat2WR <- mat2WR\n  #RES$thres <- thres\n  #RES$allgn <- names(score.genes)\n  #RES$allsp <- names(score.species)\n  #RES$scoregn <- score.genes\n  #RES$scoresp <- score.species\n  #RES$TFgn <- score.genes>thres\n  #RES$TFsp <- score.species>thres\n  RES$outgn <- out.genes\n  RES$outsp <- out.species\n  return(RES)\n}\n\n# Function to detect cell outliers (species and genes)\ndetect.cell.outliers <- function(mat2WR, k = 3) {\n  MAT <- mat2WR\n  detect.island <- function(arr) {\n    spi.names <- names(arr)\n    spi <- 1:length(spi.names)\n    names(spi) <- spi.names\n    true.names <- names(arr)[arr == TRUE]\n    if (length(true.names) == 1) {\n      return(list(true.names))\n    }\n    else if (length(true.names) > 1) {\n      true.i <- spi[true.names]\n      res<-dist(true.i)\n      table.i <- cbind(t(combn(attributes(res)$Labels, 2)), array(res))\n      in.island<-NULL\n      if (length(table.i[table.i[, 3] == \"1\", 3]) == 0) {\n        in.island <- \"nopair\"\n        list.i <- NULL\n      }\n      if (length(table.i[table.i[,3] == \"1\", 3]) == 1) {\n        in.island <- table.i[table.i[,3] == \"1\", c(1, 2)]\n        list.i <- list(in.island)\n      }\n      if (is.null(in.island)) {\n        table.small <- table.i[table.i[,3] == \"1\",c(1,2)]\n        list.i <- list()\n        for (i in 1:nrow(table.small)) list.i[[i]] <- table.small[i, ]\n        for (i in 1:(length(list.i) - 1)) {\n          for (j in (i+1):length(list.i)) {\n            if (length(intersect(list.i[[i]], list.i[[j]])) > 0) {\n              list.i[[i]] <- c(list.i[[i]], list.i[[j]])\n              list.i[[j]] <- \"out\"\n              list.i[[i]] <- unique(list.i[[i]])\n            }\n          }\n        }\n        list.i2 <- list()\n        w <- 0\n        for (i in 1:length(list.i)) {\n          if ((length(list.i[[i]]) > 1)&&(list.i[[i]][1] != \"out\")) {\n            w <- w+1\n            list.i2[[w]] <- list.i[[i]]\n            in.island <- c(in.island, list.i[[i]])\n          }\n        }\n        list.i <- list.i2\n      }\n      out.island <- as.list(setdiff(true.names, in.island))\n      return(c(list.i, out.island))\n    }\n  }\n  outl.sub <- function(x, k) {\n    return(x > quantile(x)[4] + k * IQR(x) + 1e-10)\n  }\n  MATspgn <- normalize(mat2WR, \"genes\") * normalize(mat2WR, \"species\")\n  testspgn1 <- apply(MATspgn, 2, outl.sub, k = k)\n  testspgn2 <- t(apply(MATspgn, 1, outl.sub, k = k))\n  testspgn <- testspgn1 * testspgn2\n  testFALSE <- testspgn\n  testFALSE[testFALSE == FALSE] <- 0\n  testFALSE[testFALSE == TRUE] <- 1\n  if (sum(testFALSE) > 0) {\n    out.list <- apply(testspgn, 2, detect.island)\n    genes <- colnames(testspgn)\n    res <- c(NA,NA)\n    for (i in 1:length(out.list)) {\n      if (!is.null(out.list[[i]])) {\n        for (j in 1:length(out.list[[i]])) {\n          if (length(out.list[[i]][[j]]) == 1) res <- rbind(res, c(out.list[[i]][[j]], genes[i]))\n          if (length(out.list[[i]][[j]]) > 1) {\n            vals <- MATspgn[out.list[[i]][[j]], genes[i]]\n            multi = c(names(vals)[vals == max(vals)])\n            if(length(multi) > 1){\n              x = cbind(multi, rep(genes[i],length(multi)))\n              res <- rbind(res, x)\n            }\n            else{\n              res <- rbind(res, c(multi, genes[i]))\n            }\n          }\n        }\n      }\n    }\n    colnames(res) <- c(\"Species\", \"Genes\")\n    ##we construct the MATfinal\n    MATfinal <- testspgn\n    MATfinal[,] <- 0\n    for (w in 2:nrow(res)) MATfinal[res[w, 1], res[w, 2]] <- 1\n    RESULT <- NULL\n    #RESULT$mat2WR <- mat2WR\n    #RESULT$matspgn <- MATspgn\n    #RESULT$matfinal <- MATfinal\n    #RESULT$testFALSE <- testFALSE\n    RESULT$outcell <- res[2:nrow(res), ]\n    return(RESULT)\n  } \n  else return(NULL)\n}\n# Fonction to plot 2WR matrix\n\nplot2WR <- function(matrixWR2) {\n  WR <- normalize(matrixWR2)\n  names <- list()\n  names[[1]] <- \"gene\"\n  names[[2]] <- \"specie\"\n  names[[3]] <- \"value\"\n  MAT <- matrix(nrow = length(WR), ncol = 3)\n  colnames(MAT) <- names\n  k <- 1\n  for (i in 1:nrow(WR)) {\n    for (j in 1:ncol(WR)) {\n      MAT[k, 2] <- rownames(WR)[i]\n      MAT[k, 1] <- colnames(WR)[j]\n      MAT[k, 3] <- WR[i, j]\n      k <- k + 1\n    }\n  }\n  \n  MAT <- as.data.frame(MAT)\n  MAT$gene <- as.character(MAT$gene)\n  MAT$gene <- factor(MAT$gene, levels=unique(MAT$gene))\n  MAT$specie <- as.character(MAT$specie)\n  MAT$value <- as.numeric(as.character(MAT$value))\n  \n  genes <-  MAT$gene\n  species <- MAT$specie\n  values <- MAT$value\n  \n  pl <- ggplot(MAT, aes(genes, species, z = values))\n  pl <- pl + geom_tile(aes(fill = values)) + theme_bw() + scale_fill_gradient(low = \"white\", high = \"blue\")\n  pl <- pl + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 13, color = \"black\"))\n  pl <- pl + theme(axis.text.y = element_text(angle = 00, hjust = 1, size = 13, color = \"black\"))\n  pl <- pl + theme(axis.title.y = element_text(size = rel(1.8), angle = 90))\n  pl <- pl + theme(axis.title.x = element_text(size = rel(1.8), angle = 00))\n  # pl + coord_fixed(ratio=1/5)\n  return(pl)\n}\n\n# Function to plot species in Distatis compromise\nplotDistatisPartial <- function(trees, distance = \"patristic\", bvalue = 0, gene.names = NULL, method.imp = \"IPCA\", ncp = 3, center = FALSE, scale = FALSE, maxiter = 1000, Norm = \"none\") {\n  trees <- rename.genes(trees, gene.names = gene.names)\n  RES <- NULL\n  matrices <- trees2matrices(trees, distance = distance, bvalue = bvalue)\n  if (method.imp == \"IPCA\"){\n    matrices <- impPCA.multi(matrices, ncp = ncp, center = center, scale = scale, maxiter = maxiter)\n  }\n  else if (method.imp == \"MEAN\"){\n    matrices <- impMean(matrices)\n  }\n  Dist <- mat2Dist(matrices, Norm = Norm)\n  GraphDistatisPartial(Dist$res4Splus$F, Dist$res4Splus$PartialF)\n}\n\n# Function to vizualize a specific species\n\nVizualizeSpe <- function(trees, species, distance = \"patristic\", bvalue = 0, gene.names = NULL, method.imp = \"IPCA\", ncp = 3, center = FALSE, scale = FALSE, maxiter = 1000){\n  matrices <- trees2matrices(trees, distance = distance, bvalue = bvalue)\n  if (method.imp == \"IPCA\"){\n    TAB <- impPCA.multi(matrices, ncp = ncp, center = center, scale = scale, maxiter = maxiter)\n  }\n  else if (method.imp == \"MEAN\"){\n    TAB <- impMean(matrices)\n  }\n  else{\n    stop (\"You should choose an imputation method : MEAN or IPCA\")\n  }\n  nam <- rownames(TAB[[1]])\n  listx = vector()\n  listy = vector()\n    GENEi<-NULL\n    SP<-species\n    T1 <- lapply(TAB, function(x) (x[SP, nam]))\n    T1m <- matrix(unlist(T1), nrow = length(trees), byrow = TRUE)\n    Means.T1m <- apply(T1m, 2, mean)\n    alphas <- seq(0, 2 * pi, length.out = length(nam) + 1)\n    alphas <- alphas[1:length(nam)]\n    for (i in 1:length(trees)) {\n      genei <- T1m[i, ] / Means.T1m\n      genei[is.na(genei)] <- 1\n      GENEi <- c(GENEi, genei)\n      x <- genei * cos(alphas)\n      y <- genei * sin(alphas)\n      x[is.na(x)] <- 0\n      y[is.na(y)] <- 0\n      listx = append(listx, x)\n      listy = append(listy, y)\n    }\n  SP <- species\n  GENEi <- NULL\n  T1 <- lapply(TAB, function(x) (x[SP, nam]))\n  T1m <- matrix(unlist(T1), nrow = length(trees), byrow = TRUE)\n  ##T1m gives 1 plot corresponding to \"Kla\" for each gene.\n  Means.T1m <- apply(T1m, 2, mean)\n  ##we check angles\n  alphas <- seq(0, 2 * pi, length.out = length(nam) + 1)\n  alphas <- alphas[1:length(nam)]\n  ##CIRCLE:\n  xc <- rep(1, length(nam) + 1) * cos(seq(0, 2 * pi, length.out = length(nam) + 1))\n  yc <- rep(1, length(nam) + 1) * sin(seq(0, 2 * pi, length.out = length(nam) + 1))\n  ##we check angles\n  xc <- xc[1:length(nam)]\n  yc <- yc[1:length(nam)]\n  ##for each gene, the ray is given by the proportion:\n  plot((max(abs(listx)) / max(xc)) * xc, (max(abs(listy)) / max(yc)) * yc, type = \"n\", xlim = c(-max(abs(listx)) - 2, max(abs(listx)) + 2), ylim = c(-max(abs(listy))-2, max(abs(listy)) + 2), frame.plot = FALSE, axes = FALSE, xlab = \"\", ylab = \"\")\n  text((max(abs(listx)) / max(xc)) * xc, (max(abs(listy)) / max(yc)) * yc, labels = nam, col = \"light grey\")\n  for (i in 1:length(trees)) {\n    genei <- T1m[i,] / Means.T1m\n    genei[is.na(genei)] <- 1\n    GENEi <- c(GENEi, genei)\n    x <- genei * cos(alphas)\n    y <- genei * sin(alphas)\n    x[is.na(x)] <- 0\n    y[is.na(y)] <- 0\n    polygon(xc, yc, border = \"light grey\", lwd = 0.54)\n    polygon(x, y, border = \"red\", lwd = 0.8)\n    text(-max(max(abs(listx)) / max(xc) * xc), -max(max(abs(listy)) / max(yc) * yc), SP, cex = 2)\n  }\n}\n\n# Function to vizualize a specific gene\nVizualizeGene <- function(trees, gene, distance = \"patristic\", bvalue = 0, gene.names = NULL, method.imp = \"IPCA\", ncp = 3, center = FALSE, scale = FALSE, maxiter = 1000){\n  matrices <- trees2matrices(trees, distance = distance, bvalue = bvalue)\n  if (method.imp == \"IPCA\"){\n    TAB <- impPCA.multi(matrices, ncp = ncp, center = center, scale = scale, maxiter = maxiter)\n  }\n  else if (method.imp == \"MEAN\"){\n    TAB <- impMean(matrices)\n  }\n  else{\n    stop (\"You should choose an imputation method : MEAN or IPCA\")\n  }\n  nam <- rownames(TAB[[1]])\n  listx = vector()\n  listy = vector()\n    for (j in 1:length(nam)) { ##for each speciew\n      SP <- nam[j]\n      T1 <- lapply(TAB, function(x,y) (x[SP,nam]))\n      T1m <- matrix(unlist(T1), nrow = length(trees), byrow = TRUE)\n      Means.T1m <- apply(T1m, 2, mean)\n      genei <- T1m[gene,]/Means.T1m\n      alphas <- seq(0,2 * pi, length.out = length(nam) + 1)\n      alphas <- alphas[1:length(nam)]\n      x <- genei * cos(alphas)\n      y <- genei * sin(alphas)\n      x[is.na(x)] <- 0\n      y[is.na(y)] <- 0\n      listx = append(listx, x)\n      listy = append(listy, y)\n    }\n  plot(0, 0, type = \"n\", xlim = c(-max(abs(listx)) - 2, max(abs(listx)) + 2), ylim = c(-max(abs(listy)) - 2, max(abs(listy)) + 2), frame.plot = FALSE, axes = FALSE, xlab = \"\", ylab = \"\", col.main = \"black\", cex.main = 1.5)\n  title(gene)\n  for (j in 1:length(nam)) { ##for each speciew\n    SP <- nam[j]\n    T1 <- lapply(TAB, function(x,y) (x[SP,nam]))\n    T1m <- matrix(unlist(T1), nrow=length(trees), byrow=TRUE)\n    Means.T1m <- apply(T1m, 2, mean)\n    genei <- T1m[gene,]/Means.T1m\n    xc <- rep(1, length(nam) + 1) * cos(seq(0,2 * pi, length.out = length(nam) + 1))\n    yc <- rep(1, length(nam) + 1) * sin(seq(0,2 * pi, length.out = length(nam) + 1))\n    ##we check angles\n    alphas <- seq(0,2 * pi, length.out = length(nam) + 1)\n    alphas <- alphas[1:length(nam)]\n    x <- genei * cos(alphas)\n    y <- genei * sin(alphas)\n    x[is.na(x)] <- xc[j]\n    y[is.na(y)] <- yc[j]\n    polygon(xc, yc, border=\"light grey\", lwd = 0.5)\n    points(x, y, pch = 19, cex = 0.2, col = \"red\")\n    polygon(x, y, border =\"red\", lwd = 0.1)\n  }\n}\n",
    "created" : 1499939403590.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "974210795",
    "id" : "594C5ACD",
    "lastKnownWriteTime" : 1499939425,
    "last_content_update" : 1499939425558,
    "path" : "~/Documents/Phylter/PhylteR/R/PhylteR.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}