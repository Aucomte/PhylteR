{
    "collab_server" : "",
    "contents" : "######################################################### \n##                   Damien M. de Vienne               ##\n##                   Phylo-MCOA functions              ##\n##                        Fev. 2016                    ##\n##                       Version 1.5.2 (JP edition)    ##\n##                                                     ##\n##         Go to http://phylomcoa.cgenomics.org/       ##\n##        for tutorial, help for installing, and       ##\n##           description of all the functions          ##\n##                                                     ##\n## If you use this tool for a publication, please cite ##\n##   de Vienne, DM., Ollier, S and Aguileta, G. 2012.  ##\n##           Molecular Biology and Evolution           ## \n#########################################################\n#########################################################\n## LOG\n## - July 13 2012: Added a control for the presence\n##  of duplicated species in trees (not handled)\n##  \n## - Novemver 9 2012: added functionality to correctly follow\n##   the names of genes and species after complete outliers\n##   removal. (Thanks to BÃ©atrice Roure!)\n##  \n## - April 22 2013: bug correction in gen.trees\n##  \n## - Nov 2013: fixed a problem due to the new release of ade4 (v1.6.2):\n##  Environment of mcoa2() function was not well defined\n##  (thanks to Diogo Silva for letting me know!)\n##\n## - Fev 2016: Solved bug related to the \"soustabk: non conformable array\" that was\n##   so annoying for so long and for so many people...\n##   + minor corrections also on the appearance of loading bars.\n##\n## - June 2016: Corrected problem with patristic distance when many\n##   patristic distances equal to 0. (thanks to JP Flandrois)\n\nhead.start<-function() {\n  #cat (\"\\n\\n\\n######################################################################\\n\") \n  #cat (\"###    Phylo-MCOA version 1.5.2, June 2016 (JP edition)                     ###\\n\") \n  #cat (\"### For any help, visit http://lbbe.univ-lyon1.fr/-Phylomcoa-.html ###\\n\")\n  #cat (\"###           Type ls() for a list of functions                    ###\\n\")\n  #cat (\"###                                                                ###\\n\")\n  #cat (\"###   de Vienne, DM. Ollier, S and Aguileta, G. 2012               ###\\n\")\n  #cat (\"###           Molecular Biology and Evolution                      ###\\n\")\n  #cat (\"######################################################################\\n\\n\")\n  check<-rownames(installed.packages())\n  miss<-setdiff(c(\"ape\",\"ade4\",\"utils\",\"lattice\"), check)\n  if (length(miss)>0) {\n    cat (\"\\n\\n  **WARNING**! The following packages are missing: \\n  \")\n    cat (miss, sep=\", \")\n    cat (\"\\n  DO YOU WANT TO INSTALL THEM NOW? (y/n)\")\n    REP<-\"0\"\n    while(REP!=\"y\" && REP!=\"n\") {\n      REP<-scan(what=\"character\", nlines=1, quiet=TRUE)\n    }\n    if (REP==\"y\") {          \n      install.packages(miss)\n    }\n    else cat (\"\\n\\n Some functions will not work. Please install the required packages\\n\\n\\n\") \n  }\n  rm(check)\n  rm(miss)\n}\nhead.start()\n\nrequire(ape)\nrequire(ade4)\nrequire(utils)\nrequire(lattice)\n#######################################\n### FONCTIONS FOR THE MCOA ANALYSIS ###\n#######################################\n\ntrees2matrices<-function(trees, distance=\"nodal\",bvalue=0) {\n  ##progress bar\n    print(\"Conversion from trees to matrices:\")\n    pb<-txtProgressBar(style=3, char=\".\")\n    progress<-c(0,1:(length(trees)-1)/(length(trees)-1))\n    list.trees<-list()  \n    for (i in 1:length(trees)) {\n        setTxtProgressBar(pb, progress[i])    \n        tree<-trees[[i]]\n        if (distance==\"nodal\") {\n            if (bvalue!=0) {\n                if (!is.null(tree$node.label)) { \n                    l<-1:Nnode(tree)\n                    indices.nodes<-l[as.numeric(tree$node.label)<bvalue]+Ntip(tree)\n                    if (length(indices.nodes)>0) {\n                        for (j in 1:length(indices.nodes)) {\n                            tree$edge.length[tree$edge[,1]==indices.nodes[j]]<-1e-10\n                        }   \n                    }\n                    tree<-di2multi(tree, tol=1e-9)\n                }\n                else {\n                    tree<-di2multi(tree, tol=bvalue)              \n                }\n            }\n            tree.brlen <- compute.brlen(tree, 1)\n        }\n        else if (distance==\"patristic\") {\n            if (bvalue!=0) {\n                l<-1:Nnode(tree)\n                indices.nodes<-l[as.numeric(tree$node.label)<bvalue]+Ntip(tree)\n                if (length(indices.nodes)>0) {\n                    for (j in 1:length(indices.nodes)) {\n                        tree$edge.length[tree$edge[,1]==indices.nodes[j]]<-1e-10\n                    }   \n                }\n                tree<-di2multi(tree, tol=1e-9)\n            }\n            tree.brlen<-tree\n        }\n        list.trees[[i]]<- tree.brlen\n    }\n    close(pb)\n    TRS<-lapply(list.trees, cophenetic)\n    return(TRS)\n}\n\ngestion.mat<-function(matrices) {\n  ##progress bar\n  print (\"Estimation of the quality of the dataset...\")\n  pb<-txtProgressBar(style=3, char=\".\")\n  progress<-c(0,1:(length(matrices)-1)/(length(matrices)-1))\n  qual<-0\n  listsp<-colnames(matrices[[1]])\n  for (i in 2:length(matrices)) {\n    setTxtProgressBar(pb, progress[i])    \n    listsp<-union(listsp,colnames(matrices[[i]]))\n  }\n  length.indiv<-unlist(lapply(lapply(matrices, colnames), length))\n  tmp<-rep(1,length(length.indiv))\n  testqual<-tmp[(length.indiv==length(listsp))==FALSE]\n  if (length(testqual)>0) qual<-1  \n  close(pb)\n  if (qual==1) {\n    pb<-txtProgressBar(style=3, char=\".\")\n    listsp<-colnames(matrices[[1]])\n    for (i in 2:length(matrices)) {\n      setTxtProgressBar(pb, progress[i])    \n      listsp<-union(listsp,colnames(matrices[[i]]))\n    }\n    close(pb)\n    pb<-txtProgressBar(style=3, char=\".\")\n    newcol<-list()\n    for (i in 1:length(matrices)) {\n      ##print(i)\n      setTxtProgressBar(pb, progress[i])    \n      newcol[[i]]<-setdiff(listsp,colnames(matrices[[i]]))\n      matrices[[i]]<-cbind(matrices[[i]], matrix(ncol=length(newcol[[i]]), nrow=nrow(matrices[[i]]),dimnames=list(colnames(matrices[[i]]),newcol[[i]])))\n      matrices[[i]]<-rbind(matrices[[i]], matrix(ncol=ncol(matrices[[i]]), nrow=length(newcol[[i]]),dimnames=list(newcol[[i]],colnames(matrices[[i]]))))\n    }\n    close(pb)\n  }\n  mat1 <- matrices[[1]]\n  species1 <- row.names(mat1)      \n  len2<-length(species1)\n  ALL<- list()\n  ALL[[1]]<-mat1\n  pb<-txtProgressBar(style=3, char=\".\")  \n  for(i in 2:length(matrices)){\n    setTxtProgressBar(pb, progress[i])    \n    mati <- matrices[[i]]\n    speciesi <- row.names(mati)\n    indice <- (1:len2)[species1[1] == speciesi]\n    for(j in 2:len2){\n      indice[j] <- (1:len2)[species1[j] == speciesi]\n    }\n    mati <- mati[indice,]\n    mati <- mati[, indice]\n    ALL[[i]] <- mati\n  }\n  if (qual==1) {\n    TEST<-unlist(ALL)\n    nbcase<-nrow(ALL[[1]])*nrow(ALL[[1]])\n    Nbt<-length(ALL)\n    allcase<-0:(Nbt-1)\n    MEANS<-array()\n    for (i in 1:nbcase) {\n      MEANS[i]<-mean(TEST[i+allcase*nbcase],na.rm=TRUE)\n    }\n    MEANMAT<-matrix(MEANS,nrow=nrow(ALL[[1]]), ncol=ncol(ALL[[1]]))\n    rownames(MEANMAT)<-colnames(MEANMAT)<-colnames(ALL[[1]])\n    MEANMAT[is.na(MEANMAT)]<-mean(MEANMAT, na.rm=TRUE)\n    for (i in 1:length(ALL)) {      \n      if (length(newcol[[i]])>0) {\n        ALL[[i]][,newcol[[i]]]<-MEANMAT[,newcol[[i]]]\n        ALL[[i]][newcol[[i]],]<-MEANMAT[newcol[[i]],]\n      }\n    }\n  }\n  close(pb)\n  return(ALL)\n}\n\nmat2mcoa<-function(matrices, wtts=NULL, scannf=TRUE, nf=\"auto\") {\n  print (\"MCOA analysis... YEAH\")\n  print (\"This analysys may take a few minutes... Be patient...\")\n  dist.all <- lapply(matrices, as.dist)\n  dist.all <- lapply(dist.all, sqrt)\n  dist.all <-lapply(dist.all, cailliez, cor.zero=FALSE)\n  \n  dist.all <- kdist(dist.all)\n  if (nf==\"auto\") {\n    scannf<-FALSE\n    if (ncol(matrices[[1]])>21) nf<-20\n    else nf<-ncol(matrices[[1]])-1\n  }\n  dist.all.ktab<- kdist2ktab(dist.all)   \n  if (!is.null(wtts)){\n    wtts<-as.numeric(wtts)\n    wtts<-abs(wtts) #we take the absolute values of the weight (in case negative likelihood values are given\n    dist.all.ktab$tabw<-wtts\n    dist.all.mcoa<-mcoa2(dist.all.ktab,option=\"internal\", scannf=scannf,nf=nf)\n  }\n  else {\n      dist.all.mcoa<-mcoa(dist.all.ktab, scannf=scannf, nf=nf)\n  }\n  return(dist.all.mcoa)\n}\n\nmcoa2WRmat <- function (mcoa) {\n  ##we reduce the number of dimensions for faster calculations \n  print (\"Computing the 2WR matrix...\")\n  matrix.vector<-matrix(ncol=ncol(mcoa$SynVar), nrow=length(mcoa$TL[,1]))\n  array.vector<-array()\n  pb<-txtProgressBar(style=3, char=\".\")\n  progress<-c(0,1:(length(mcoa$TL[,1])-1)/(length(mcoa$TL[,1])-1))\n  for (i in 1:length(mcoa$TL[,1])) {      \n    setTxtProgressBar(pb,progress[i])\n    matrix.vector[i,]<-(mcoa$Tl1[i,]-mcoa$SynVar[mcoa$TL[i,2],])^2\n    array.vector[i]<-sqrt(sum(matrix.vector[i,]))\n  }\n  big.mat<-matrix(ncol=length(mcoa$lambda[,1]), nrow=length(mcoa$SynVar[,1]))\n  for (i in 1:length(mcoa$lambda[,1])) big.mat[,i]<-array.vector[mcoa$TL[,1]==paste(\"X\",i,sep=\"\")]\n  big.mean <- array()\n  big.sd <- array()\n  big.vc <- array()\n  for (i in 1:length(mcoa$lambda[,1])) {\n    big.mean[i]<-mean(big.mat[,i])\n    big.sd[i]<-sd(big.mat[,i])\n    big.vc[i]<-big.sd[i]/big.mean[i]\n  }  \n  rownames(big.mat)<-rownames(mcoa$SynVar)\n  close(pb)\n  return(big.mat)\n}\n\n\npMCOA<-function(trees, distance=\"nodal\", bvalue=0, wtts=NULL, scannf=TRUE, nf=\"auto\", gene.names=NULL) {\n  RES<-NULL\n  if (is.list(trees)) {\n    if (class(trees[[1]])!=\"phylo\") stop (\"The trees should be in the \\\"phylo\\\" format!\")      \n  }\n  if (class(trees)==\"character\") {\n    trees<-read.tree(trees)\n  }\n  if (is.null(gene.names)&&is.null(names(trees))) gene.names<-paste(\"GEN\",1:length(trees), sep=\"\")\n  if (is.null(gene.names)&&!is.null(names(trees))) gene.names<-names(trees)  \n  if (length(gene.names)!=length(trees)) stop (\"The number of gene names and the number of trees differ!\")\n  ##check for duplications\n  check.dup<-lapply(trees, function(x) {x$tip.label[duplicated(x$tip.label)]})\n  if (sum(unlist(lapply(check.dup, length)))>0) {\n    cat (\"-------- ATTENTION!! There are some duplicated species in some of your trees: -------\")\n    for (w in 1:length(trees)) {\n      if (length(check.dup[[w]])>0) cat(paste(\"\\n     - Species \", check.dup[[w]], \" present more than once in tree \",w,\"\\n\\n\",sep=\"\"))\n    }\n    stop (\"Remove or rename duplicated species and try again.\\n\\n\", call.=FALSE)\n  }\n  \n  b<-trees2matrices(trees, distance=distance, bvalue=bvalue)\n  c<-gestion.mat(b)\n  d<-mat2mcoa(c, wtts=wtts, scannf=scannf, nf=nf)\n  e<-mcoa2WRmat(d)\n  ##Associating names of genes to trees and to the 2WR matrix: \n  for (i in 1:length(trees)) trees[[i]]$name<-gene.names[i]\n  colnames(e)<-gene.names\n  ##Output\n  RES$trees<-trees\n  names(RES$trees)<-gene.names\n  RES$mat.init<-b\n  RES$mat.ok<-c\n  RES$mcoa<-d\n  RES$mat2WR<-e\n  return(RES)\n}\n\npMCOA.complete<-function(trees, distance=\"nodal\", bvalue=0, wtts=NULL, scannf=TRUE, nf=\"auto\", gene.names=NULL, k=1.5, thres=0.2, quiet=TRUE) {\n  outl.sub<-function(x,k) {\n    return(x>quantile(x)[4]+k*IQR(x)+1e-10)\n  }\n  res1<-pMCOA(trees, distance=distance, gene.names=gene.names, bvalue=bvalue,wtts=wtts,scannf=scannf,nf=nf)\n  total.outl<-detect.complete.outliers(res1$mat2WR, k=k, thres=thres)\n  if (length(total.outl$outsp)>0 || length(total.outl$outgn)>0) {\n    cat(\"\\n\")\n    cat(\"  |----------------------------------------------------------------------|\\n\")\n    cat(\"  |----Some complete outliers have been detected. -----------------------|\\n\")\n    cat(\"  |----They are removed from the dataset and ----------------------------|\\n\")\n    cat(\"  |----the analysis is performed again ----------------------------------|\\n\")\n    cat(\"  |----------------------------------------------------------------------|\\n\")\n    cat(\"\\n\")\n    newTREES<-rm.gene.and.species(res1$trees, total.outl$outsp, total.outl$outgn)\n    newgenenames<-names(newTREES)\n    res2<-pMCOA(newTREES, gene.names=newgenenames, distance=distance, bvalue=bvalue,wtts=wtts,scannf=scannf,nf=nf)\n  }\n  else {\n    res2<-res1\n    newTREES<-res1$trees\n  }\n  ##Cell-by-cell detection.\n  res3<-detect.cell.outliers(res2$mat2WR, k=k, quiet=quiet)\n  RESU<-NULL\n  RESU$step1<-res1\n  RESU$step2<-res2\n  RESU$outcompl<-total.outl\n  RESU$outcell<-res3\n  ##we add the outall for Jean-Pierre. It contains outcell, but also the complete outlier species, in the form of sp/gn \n  RESU$outall<-res3$outcell\n  if (!is.null(total.outl$outsp)) {\n      tempsp<-cbind(rep(total.outl$outsp, each=length(colnames(res3$matfinal))), rep(colnames(res3$matfinal), length(total.outl$outsp)))\n      RESU$outall<-rbind(RESU$outall, tempsp)\n  }\n  return(RESU)\n}\n\nrm.gene.and.species<-function(trees, sp2rm, gn2rm) {\n  gene.names<-names(trees)\n  if (length(sp2rm)>0) {\n    for (i in 1:length(trees)) {\n      sp<-trees[[i]]$tip.label\n      toremove<-intersect(sp, sp2rm)\n      trees[[i]]<-drop.tip(trees[[i]], toremove)\n    }\n  }\n  if (length(gn2rm)>0) {\n    genes2keep<-setdiff(gene.names, gn2rm)\n    trees2<-list()\n    j<-0\n    for (i in 1:length(trees)) {\n      if (is.element(gene.names[i], genes2keep)) {\n        j<-j+1\n        trees2[[j]]<-trees[[i]]\n      }\n    }\n    names(trees2)<-genes2keep\n    trees<-trees2\n  }\n  return(trees)\n}\n\n\nnormalize<-function(mat, what=\"none\") {\n  if (what==\"species\") mat<-apply(mat, 2, function(x) {x/mean(x)})\n  else if (what==\"genes\") mat<-t(apply(mat, 1, function(x) {x/mean(x)}))\n  else if (what==\"none\") {\n    mat<-mat\n    cat(\"The matric is unchanged.\\n\")\n  }\n  else print (\"WARNING! Error in the kind of scaling you want! No scaling applied.\")\n  return(mat)\n}\n\n\n\ndetect.complete.outliers<-function(mat2WR, k=1.5, thres=0.5) {\n  outl.sub<-function(x,k) {\n    return(x>quantile(x)[4]+k*IQR(x)+1e-10)\n    ##note: the 1e-10 ,is because when all values are similar except one, the first one is considered as equal to the third quartile... May be a bug in quantile function?\n  }\n  tabgn<-normalize(mat2WR, \"genes\")\n  tabgn.TF<-t(apply(tabgn,1,outl.sub, k=k))\n  tabsp<-normalize(mat2WR, \"species\")\n  tabsp.TF<-apply(tabsp,2, outl.sub, k=k)\n  tabgn.TF[tabgn.TF==FALSE]<-0\n  tabgn.TF[tabgn.TF==TRUE]<-1\n  tabsp.TF[tabsp.TF==FALSE]<-0\n  tabsp.TF[tabsp.TF==TRUE]<-1\n  score.genes<-apply(tabgn.TF,2,function(x) {sum(x)/length(x)})\n  score.species<-apply(tabsp.TF,1,function(x) {sum(x)/length(x)})\n  out.genes<-names(score.genes)[score.genes>thres]\n  out.species<-names(score.species)[score.species>thres]\n  RES<-NULL\n  RES$mat2WR<-mat2WR\n  RES$thres<-thres\n  RES$allgn<-names(score.genes)\n  RES$allsp<-names(score.species)\n  RES$scoregn<-score.genes\n  RES$scoresp<-score.species  \n  RES$TFgn<-score.genes>thres\n  RES$TFsp<-score.species>thres\n  RES$outgn<-out.genes\n  RES$outsp<-out.species\n  return(RES)\n}\n\ndetect.cell.outliers<-function(mat2WR, k=3, quiet=FALSE) {\n  ans<-\"y\"\n  if (quiet==FALSE) {\n    cat(\"        \\nYou are about to do the Cell-by-cell detection of outliers.\\n\")\n    cat(\"THIS SHOULD BE DONE ON A 2WR MATRIX COMING FROM A DATASET WITHOUT COMPLETE OUTLIERS.\\n\")\n    cat(\" Please use the function \\\"detec.complete.outliers()\\\" prior to do this analysis.\\n\\n\")\n    cat(\"Do you want to continue ? (y/n)\\n\")\n    ans<-scan(what=\"character\", n=1, quiet=TRUE) \n  }\n  if (ans==\"y\") {\n    MAT<-mat2WR\n    detect.island<-function(arr) {\n      spi.names<-names(arr)\n      spi<-1:length(spi.names)\n      names(spi)<-spi.names\n      true.names<-names(arr)[arr==TRUE]\n      if (length(true.names)==1) {\n        return(list(true.names))\n      }   \n      else if (length(true.names)>1) {\n        true.i<-spi[true.names]\n        res<-dist(true.i)\n        table.i<-cbind(t(combn(attributes(res)$Labels,2)), array(res))\n        in.island<-NULL\n        if (length(table.i[table.i[,3]==\"1\",3])==0) {\n          in.island<-\"nopair\"\n          list.i<-NULL\n        }\n        if (length(table.i[table.i[,3]==\"1\",3])==1) {\n          in.island<-table.i[table.i[,3]==\"1\",c(1,2)]\n          list.i<-list(in.island)\n        }\n        if (is.null(in.island)) {\n          table.small<-table.i[table.i[,3]==\"1\",c(1,2)]        \n          list.i<-list()\n          for (i in 1:nrow(table.small)) list.i[[i]]<-table.small[i,]\n          for (i in 1:(length(list.i)-1)) {\n            for (j in (i+1):length(list.i)) {\n              if (length(intersect(list.i[[i]], list.i[[j]]))>0) {\n                list.i[[i]]<-c(list.i[[i]], list.i[[j]])\n                list.i[[j]]<-\"out\"\n                list.i[[i]]<-unique(list.i[[i]])\n              }\n            }\n          }\n          list.i2<-list()\n          w<-0\n          for (i in 1:length(list.i)) {\n            if ((length(list.i[[i]])>1)&&(list.i[[i]][1]!=\"out\")) {\n              w<-w+1\n              list.i2[[w]]<-list.i[[i]]\n              in.island<-c(in.island, list.i[[i]])\n            }\n          }\n          list.i<-list.i2\n        }\n        out.island<-as.list(setdiff(true.names,in.island))\n        return(c(list.i,out.island))\n      }\n      else {\n        return(NULL)\n      }\n    }\n    outl.sub<-function(x,k) {\n      return(x>quantile(x)[4]+k*IQR(x)+1e-10)\n    }\n    MATspgn<-normalize(mat2WR, \"genes\")*normalize(mat2WR, \"species\")\n    testspgn1<-apply(MATspgn,2,outl.sub, k=k)\n    testspgn2<-t(apply(MATspgn,1,outl.sub, k=k))\n    testspgn<-testspgn1*testspgn2\n    testFALSE<-testspgn\n    testFALSE[testFALSE==FALSE]<-0\n    testFALSE[testFALSE==TRUE]<-1\n    if (sum(testFALSE)>0) {\n      out.list<-apply(testspgn,2, detect.island)\n      genes<-colnames(testspgn)\n      res<-c(NA,NA)\n      for (i in 1:length(out.list)) {\n        if (!is.null(out.list[[i]])) {\n          for (j in 1:length(out.list[[i]])) {\n            if (length(out.list[[i]][[j]])==1) res<-rbind(res, c(out.list[[i]][[j]],genes[i]))\n            if (length(out.list[[i]][[j]])>1) {\n              vals<-MATspgn[out.list[[i]][[j]],genes[i]]\n              res<-rbind(res, c(names(vals)[vals==max(vals)], genes[i]))\n            }\n          }\n        }\n      }\n      colnames(res)<-c(\"Species\", \"Genes\")\n      ##we construct the MATfinal\n      MATfinal<-testspgn\n      MATfinal[,]<-0\n      for (w in 2:nrow(res)) MATfinal[res[w,1], res[w,2]]<-1\n      RESULT<-NULL\n      RESULT$mat2WR<-mat2WR\n      RESULT$matspgn<-MATspgn\n      RESULT$matfinal<-MATfinal\n      RESULT$testFALSE<-testFALSE\n      RESULT$outcell<-res[2:nrow(res),]\n      return(RESULT)\n    }\n    else return(NULL)\n  }\n  else cat(\"\\n---Operation canceled by the user.---\\n\")\n}\n\n\n\n###########################\n### PLOTTING FUNCTIONS  ###\n###########################\nplot.2WR<-function(mat2WR, method=\"level\", scale=\"none\", main=\"2WR matrix\") {\n  if (method==\"level\") {\n    mat2WR<-normalize(mat2WR, what=scale)\n    testlat<-require(lattice)\n    if (testlat==TRUE) {\n      ok<-levelplot(t(mat2WR), xlab=\"Genes\", ylab=\"Species\", col.regions=grey(seq(1,0,length.out=100)), main=main, scales = list(x = list(rot = 90)))\n      plot(ok)\n    }\n    else {\n      cat(\"The lattice package should be installed for using this function\\n\")\n      cat(\"Type install.packages(\\\"lattice\\\") at the R prompt to do so.\\n\")\n    }\n  }\n  if (method==\"all\") {\n    MAT<-mat2WR\n    add.line<-function(xx,nentities) {\n      abline(v=xx[seq(nentities,nrow(xx), by=nentities),], col=\"grey\")\n    }  \n    add.text<-function(xx,nentities, yy, lab) {\n      yy<-yy-0.5\n      where<-xx[seq(trunc(nentities/2),nrow(xx), by=nentities),]\n      text(where,rep(yy,length(where)), label=lab, col=\"red\")\n      abline(v=xx[seq(nentities,nrow(xx), by=nentities),], col=\"grey\")\n    }    \n    MATsp<-normalize(MAT,\"species\")\n    MATgn<-normalize(MAT,\"genes\")\n    MATspgn<-normalize(MAT,\"genes\")*normalize(MAT,\"species\")\n    NN.per.gene<-cbind(rep(rownames(MAT), ncol(MAT)), rep(colnames(MAT),each=nrow(MAT)))\n    NN.per.species<-cbind(rep(rownames(MAT), each=ncol(MAT)), rep(colnames(MAT),nrow(MAT)))\n    NN.per.gn.sp<-cbind(rep(rownames(MAT), ncol(MAT)), rep(colnames(MAT),each=nrow(MAT)))\n    NN.per.gene<-cbind(NN.per.gene, array(MATgn))\n    NN.per.species<-cbind(NN.per.species, array(t(MATsp))) \n    NN.per.gn.sp<-cbind(NN.per.gn.sp, array(MATspgn))\n    par(mfrow=c(3,1))\n    par(mar=c(1,2,2,0))\n    mini<-min(as.numeric(NN.per.gene[,3]))\n    maxi<-max(as.numeric(NN.per.gene[,3]))\n    interv<-maxi-mini\n    mini<-mini-interv/10\n    maxi<-maxi+interv/10\n    xx<-barplot(as.numeric(NN.per.gene[,3]), main=\"genes\", ylim=c(mini,maxi))\n    add.line(xx, length(unique(NN.per.gene[,1])))\n    add.text(xx, length(unique(NN.per.gene[,1])), maxi, lab=unique(NN.per.gene[,2]))\n    mini<-min(as.numeric(NN.per.species[,3]))\n    maxi<-max(as.numeric(NN.per.species[,3]))\n    interv<-maxi-mini\n    mini<-mini-interv/10\n    maxi<-maxi+interv/10\n    xx<-barplot(as.numeric(NN.per.species[,3]), main=\"species\", ylim=c(mini,maxi))\n    add.line(xx, length(unique(NN.per.species[,2])))\n    add.text(xx, length(unique(NN.per.gene[,2])), maxi, lab=unique(NN.per.gene[,1]))\n    mini<-min(as.numeric(NN.per.gn.sp[,3]))\n    maxi<-max(as.numeric(NN.per.gn.sp[,3]))\n    interv<-maxi-mini\n    mini<-mini-interv/10\n    maxi<-maxi+interv/10\n    xx<-barplot(as.numeric(NN.per.gn.sp[,3]), main=\"genes x species\", ylim=c(mini,maxi))\n    add.line(xx, length(unique(NN.per.gene[,1])))\n    add.text(xx, length(unique(NN.per.gn.sp[,1])), maxi, lab=unique(NN.per.gn.sp[,2]))    \n  }\n}\n\nplot.2WR.out<-function(OUT, mat2WR=NULL, lwd=2, lty=1, pch=19, col.lines=\"red\", col.points=\"red\") {\n  if (!is.null(mat2WR)) mat2WR<-mat2WR\n  else mat2WR<-OUT$mat2WR\n  horiz<-NULL\n  vertic<-NULL\n  cells<-NULL\n  if (!is.null(OUT$outgn)) {\n    ##we create vertical lines\n    x<-1:length(OUT$TFgn)\n    vertic<-x[OUT$TFgn==TRUE]\n  }\n  if (!is.null(OUT$outsp)) {\n    ##we create vertical lines\n    x<-1:length(OUT$TFsp)\n    horiz<-x[OUT$TFsp==TRUE]\n  }\n  if (!is.null(OUT$outcell)) {\n    y<-rep(1:nrow(OUT$matfinal),ncol(OUT$matfinal))\n    x<-rep(1:ncol(OUT$matfinal),each=nrow(OUT$matfinal))\n    xy<-cbind(x, y, array(OUT$matfinal))\n    xy<-xy[xy[,3]==1,1:2]\n    cells<-xy\n    print(cells)\n  }\n  funpanel<-function(...) {\n    panel.levelplot(...)\n    panel.abline(h=horiz, v=vertic, col=col.lines, lty=lty,lwd=lwd)\n    panel.points(cells, pch=pch, col=col.points)\n  }\n  levelplot(t(mat2WR), xlab=\"Genes\", ylab=\"Species\", col.regions=grey(seq(1,0,length.out=100)), scales = list(x = list(rot = 90)), panel=funpanel)\n}\n\nbarplot.complete<-function(OUT, col.signif=\"red\", col.non.signif=\"grey\", las=2, cex.axis=1, cex.names=1) {\n  thres<-OUT$thres\n  par(mfrow=c(2,1))\n  colgn<-rep(col.non.signif, length(OUT$scoregn))\n  colgn[OUT$TFgn]<-col.signif\n  colsp<-rep(col.non.signif, length(OUT$scoresp))\n  colsp[OUT$TFsp]<-col.signif\n  barplot(OUT$scoregn, col=colgn, main=\"Genes\", ylab=\"Outlier detection proportion\", las=las, cex.axis=cex.axis, cex.names=cex.names)\n  abline(h=OUT$thres, lty=2, lwd=2, col=\"grey\")\n  barplot(OUT$scoresp, col=colsp, main=\"Species\", ylab=\"outlier detection proportion\", las=las, cex.axis=cex.axis, cex.names=cex.names)\n  abline(h=OUT$thres, lty=2, lwd=2, col=\"grey\")\n}\n\nplot.phylomcoa<-function(MCOA,axe, sub=\"\") {\n  sp.coor <- function (MCOA) {\n    star.center<-MCOA$SynVar[, c(1, axe)]\n    return (star.center)\n  }\n  star <- sp.coor(MCOA)\n  starall<-star\n  for (k in 2:nrow(MCOA$cov2)) {\n    starall <- rbind.data.frame(starall, MCOA$SynVar[, c(1,axe)])\n  }\n  names(starall) <- names(MCOA$Tl1)[c(1, axe)]\n  opar<-c(5, 4, 4, 2) + 0.1\n  par(mar = c(0.1, 0.1, 0.1, 0.1))\n  on.exit(par(opar))  \n  s.match(MCOA$Tl1[, c(1,axe)], starall, clab = 0, sub = sub, csub = 1.5, edge = FALSE)\n  s.label(MCOA$SynVar[, c(1, axe)], add.plot = TRUE)  \n}\n\n\n\n########################################\n### GENERATION OF SIMULATED DATASETS ###\n########################################\n\ngen.trees<-function(Ntrees, Ntiptotal, Nspmove, NbweirdGenes=0) {\n  res<-list()\n  selec<-NULL\n  anames<-NULL\n  a<-rtree(Ntiptotal)\n  if (Nspmove>0) {\n    anames<-sample(a$tip.label, Nspmove)\n    a<-drop.tip(a, anames)\n  }\n  for (i in 1:Ntrees){\n    res[[i]]<-a\n    if (Nspmove>0) {\n      for (j in 1:Nspmove) {\n        b<-rtree(2)\n        nodelabs<-(Ntip(res[[i]])+1):(Ntip(res[[i]])+Ntip(res[[i]])-1)\n        tiplab<-c(anames[j], \"out\")\n        b$tip.label<-tiplab\n        tr<-bind.tree(res[[i]],b, where=sample(nodelabs, 1))\n        tr<-drop.tip(tr, tiplab[2])\n        tr<-multi2di(tr)\n        tr$edge.length[tr$edge.length==0]<-mean(tr$edge.length)\n        res[[i]]<-tr\n      }\n    }\n  }\n  if (NbweirdGenes>0) {\n    sam<-1:Ntrees\n    selec<-sample(sam,NbweirdGenes)\n    for (k in selec) {\n      res[[k]]<-rtree(Ntiptotal)\n    }\n  }\n  RES<-NULL\n  RES$trees<-res\n  RES$gn<-selec  \n  RES$sp<-anames\n  return(RES)\n}\n\nadd.outliers<-function(trees, nbrep) {\n  move.tip<-function(tree, tip) {\n    treesmall<-drop.tip(tree, tip)\n    temptree<-rtree(2)\n    temptree$tip.label[1]<-\"out\"\n    temptree$tip.label[2]<-tip\n    node.attach<-sample(unique(treesmall$edge[,1]),1)\n    treenew<-bind.tree(treesmall, temptree,where=node.attach)\n    treenew<-drop.tip(treenew,\"out\")\n    treenew<-multi2di(treenew)\n    return(treenew)\n  }\n  Ntiptotal<-Ntip(trees[[1]])\n  Ntrees<-length(trees)\n  rrr<-c(NA,NA)\n  names(rrr)<-c(\"Species\",\"Genes\")\n  for (w in 1:nbrep) {\n    which.gn<-sample(1:Ntrees, 1)\n    which.sp<-paste(\"t\",sample(1:Ntiptotal, 1),sep=\"\")\n    rrr<-rbind(rrr,c(which.sp,which.gn))\n    trees[[which.gn]]<-move.tip(trees[[which.gn]], which.sp)\n  }\n  RES<-NULL\n  RES$trees<-trees\n  RES$outl<-rrr[2:nrow(rrr),]  \n  return(RES)\n}\n",
    "created" : 1499940537282.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3760103543",
    "id" : "55E7D268",
    "lastKnownWriteTime" : 1492171242,
    "last_content_update" : 1492171242,
    "path" : "~/Documents/PhylterBU0607/pmcoa.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}